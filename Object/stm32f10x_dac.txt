; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Object\stm32f10x_dac.o --depend=.\Object\stm32f10x_dac.d --feedback=.\Object\stm32-speech-recognition.fed --cpu=Cortex-M3 --apcs=interwork -O0 -Otime -I.\Src\APP -I.\Src\BSP -I.\Src\GUI -I.\Src\CM3_SYS -I.\Src\FATFS -I.\Src\StdPeriph_Driver -I.\Src\StdPeriph_Driver\inc -I.\Src\Speech_Recog -IE:\SoftWare\KEIL\Keil4\path\ARM\INC -IE:\SoftWare\KEIL\Keil4\path\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\Object\stm32f10x_dac.crf Src\StdPeriph_Driver\src\stm32f10x_dac.c]
                          THUMB

                          AREA ||i.DAC_Cmd||, CODE, READONLY, ALIGN=2

                  DAC_Cmd PROC
;;;180      */
;;;181    void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b159              CBZ      r1,|L1.26|
;;;182    {
;;;183      /* Check the parameters */
;;;184      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;185      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;186      if (NewState != DISABLE)
;;;187      {
;;;188        /* Enable the selected DAC channel */
;;;189        DAC->CR |= CR_EN_Set << DAC_Channel;
000002  4a0c              LDR      r2,|L1.52|
000004  6812              LDR      r2,[r2,#0]
000006  f04f0301          MOV      r3,#1
00000a  fa03f300          LSL      r3,r3,r0
00000e  ea420203          ORR      r2,r2,r3
000012  4b09              LDR      r3,|L1.56|
000014  f8c32400          STR      r2,[r3,#0x400]
000018  e00a              B        |L1.48|
                  |L1.26|
;;;190      }
;;;191      else
;;;192      {
;;;193        /* Disable the selected DAC channel */
;;;194        DAC->CR &= ~(CR_EN_Set << DAC_Channel);
00001a  4a06              LDR      r2,|L1.52|
00001c  6812              LDR      r2,[r2,#0]
00001e  f04f0301          MOV      r3,#1
000022  fa03f300          LSL      r3,r3,r0
000026  ea220203          BIC      r2,r2,r3
00002a  4b03              LDR      r3,|L1.56|
00002c  f8c32400          STR      r2,[r3,#0x400]
                  |L1.48|
;;;195      }
;;;196    }
000030  4770              BX       lr
;;;197    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x40007400
                  |L1.56|
                          DCD      0x40007000

                          AREA ||i.DAC_DMACmd||, CODE, READONLY, ALIGN=2

                  DAC_DMACmd PROC
;;;240      */
;;;241    void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b159              CBZ      r1,|L2.26|
;;;242    {
;;;243      /* Check the parameters */
;;;244      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;245      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;246      if (NewState != DISABLE)
;;;247      {
;;;248        /* Enable the selected DAC channel DMA request */
;;;249        DAC->CR |= CR_DMAEN_Set << DAC_Channel;
000002  4a0c              LDR      r2,|L2.52|
000004  6812              LDR      r2,[r2,#0]
000006  f44f5380          MOV      r3,#0x1000
00000a  fa03f300          LSL      r3,r3,r0
00000e  ea420203          ORR      r2,r2,r3
000012  4b09              LDR      r3,|L2.56|
000014  f8c32400          STR      r2,[r3,#0x400]
000018  e00a              B        |L2.48|
                  |L2.26|
;;;250      }
;;;251      else
;;;252      {
;;;253        /* Disable the selected DAC channel DMA request */
;;;254        DAC->CR &= ~(CR_DMAEN_Set << DAC_Channel);
00001a  4a06              LDR      r2,|L2.52|
00001c  6812              LDR      r2,[r2,#0]
00001e  f44f5380          MOV      r3,#0x1000
000022  fa03f300          LSL      r3,r3,r0
000026  ea220203          BIC      r2,r2,r3
00002a  4b03              LDR      r3,|L2.56|
00002c  f8c32400          STR      r2,[r3,#0x400]
                  |L2.48|
;;;255      }
;;;256    }
000030  4770              BX       lr
;;;257    
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x40007400
                  |L2.56|
                          DCD      0x40007000

                          AREA ||i.DAC_DeInit||, CODE, READONLY, ALIGN=1

                  DAC_DeInit PROC
;;;105      */
;;;106    void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;107    {
;;;108      /* Enable DAC reset state */
;;;109      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;110      /* Release DAC from reset state */
;;;111      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5000          MOV      r0,#0x20000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;112    }
000014  bd10              POP      {r4,pc}
;;;113    
                          ENDP


                          AREA ||i.DAC_DualSoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_DualSoftwareTriggerCmd PROC
;;;291      */
;;;292    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
000000  b138              CBZ      r0,|L4.18|
;;;293    {
;;;294      /* Check the parameters */
;;;295      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;296      if (NewState != DISABLE)
;;;297      {
;;;298        /* Enable software trigger for both DAC channels */
;;;299        DAC->SWTRIGR |= DUAL_SWTRIG_Set ;
000002  4908              LDR      r1,|L4.36|
000004  6809              LDR      r1,[r1,#0]
000006  f0410103          ORR      r1,r1,#3
00000a  4a07              LDR      r2,|L4.40|
00000c  f8c21404          STR      r1,[r2,#0x404]
000010  e006              B        |L4.32|
                  |L4.18|
;;;300      }
;;;301      else
;;;302      {
;;;303        /* Disable software trigger for both DAC channels */
;;;304        DAC->SWTRIGR &= DUAL_SWTRIG_Reset;
000012  4904              LDR      r1,|L4.36|
000014  6809              LDR      r1,[r1,#0]
000016  f0210103          BIC      r1,r1,#3
00001a  4a03              LDR      r2,|L4.40|
00001c  f8c21404          STR      r1,[r2,#0x404]
                  |L4.32|
;;;305      }
;;;306    }
000020  4770              BX       lr
;;;307    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x40007404
                  |L4.40|
                          DCD      0x40007000

                          AREA ||i.DAC_GetDataOutputValue||, CODE, READONLY, ALIGN=2

                  DAC_GetDataOutputValue PROC
;;;437      */
;;;438    uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
000000  4601              MOV      r1,r0
;;;439    {
;;;440      __IO uint32_t tmp = 0;
000002  2200              MOVS     r2,#0
;;;441      
;;;442      /* Check the parameters */
;;;443      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;444      
;;;445      tmp = (uint32_t) DAC_BASE ;
000004  4a03              LDR      r2,|L5.20|
;;;446      tmp += DOR_Offset + ((uint32_t)DAC_Channel >> 2);
000006  202c              MOVS     r0,#0x2c
000008  eb000091          ADD      r0,r0,r1,LSR #2
00000c  4402              ADD      r2,r2,r0
;;;447      
;;;448      /* Returns the DAC channel data output register value */
;;;449      return (uint16_t) (*(__IO uint32_t*) tmp);
00000e  6810              LDR      r0,[r2,#0]
000010  b280              UXTH     r0,r0
;;;450    }
000012  4770              BX       lr
;;;451    
                          ENDP

                  |L5.20|
                          DCD      0x40007400

                          AREA ||i.DAC_Init||, CODE, READONLY, ALIGN=2

                  DAC_Init PROC
;;;124      */
;;;125    void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;126    {
;;;127      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;128      /* Check the DAC parameters */
;;;129      assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
;;;130      assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
;;;131      assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
;;;132      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
;;;133    /*---------------------------- DAC CR Configuration --------------------------*/
;;;134      /* Get the DAC CR value */
;;;135      tmpreg1 = DAC->CR;
000006  4c0d              LDR      r4,|L6.60|
000008  6822              LDR      r2,[r4,#0]
;;;136      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;137      tmpreg1 &= ~(CR_CLEAR_Mask << DAC_Channel);
00000a  f64074fe          MOV      r4,#0xffe
00000e  fa04f400          LSL      r4,r4,r0
000012  ea220204          BIC      r2,r2,r4
;;;138      /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
;;;139         mask/amplitude for wave genration */
;;;140      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;141      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;142      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;143      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;144      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
000016  e9d14500          LDRD     r4,r5,[r1,#0]
00001a  ea440405          ORR      r4,r4,r5
00001e  688d              LDR      r5,[r1,#8]
000020  ea440405          ORR      r4,r4,r5
000024  68cd              LDR      r5,[r1,#0xc]
000026  ea440305          ORR      r3,r4,r5
;;;145                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
;;;146      /* Calculate CR register value depending on DAC_Channel */
;;;147      tmpreg1 |= tmpreg2 << DAC_Channel;
00002a  fa03f400          LSL      r4,r3,r0
00002e  ea440202          ORR      r2,r4,r2
;;;148      /* Write to DAC CR */
;;;149      DAC->CR = tmpreg1;
000032  4c03              LDR      r4,|L6.64|
000034  f8c42400          STR      r2,[r4,#0x400]
;;;150    }
000038  bd30              POP      {r4,r5,pc}
;;;151    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      0x40007400
                  |L6.64|
                          DCD      0x40007000

                          AREA ||i.DAC_SetChannel1Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel1Data PROC
;;;349      */
;;;350    void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
000000  2200              MOVS     r2,#0
;;;351    {  
;;;352      __IO uint32_t tmp = 0;
;;;353      
;;;354      /* Check the parameters */
;;;355      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;356      assert_param(IS_DAC_DATA(Data));
;;;357      
;;;358      tmp = (uint32_t)DAC_BASE; 
000002  4a03              LDR      r2,|L7.16|
;;;359      tmp += DHR12R1_Offset + DAC_Align;
000004  f1000308          ADD      r3,r0,#8
000008  441a              ADD      r2,r2,r3
;;;360    
;;;361      /* Set the DAC channel1 selected data holding register */
;;;362      *(__IO uint32_t *) tmp = Data;
00000a  6011              STR      r1,[r2,#0]
;;;363    }
00000c  4770              BX       lr
;;;364    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel2Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel2Data PROC
;;;374      */
;;;375    void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
000000  2200              MOVS     r2,#0
;;;376    {
;;;377      __IO uint32_t tmp = 0;
;;;378    
;;;379      /* Check the parameters */
;;;380      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;381      assert_param(IS_DAC_DATA(Data));
;;;382      
;;;383      tmp = (uint32_t)DAC_BASE;
000002  4a03              LDR      r2,|L8.16|
;;;384      tmp += DHR12R2_Offset + DAC_Align;
000004  f1000314          ADD      r3,r0,#0x14
000008  441a              ADD      r2,r2,r3
;;;385    
;;;386      /* Set the DAC channel2 selected data holding register */
;;;387      *(__IO uint32_t *)tmp = Data;
00000a  6011              STR      r1,[r2,#0]
;;;388    }
00000c  4770              BX       lr
;;;389    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      0x40007400

                          AREA ||i.DAC_SetDualChannelData||, CODE, READONLY, ALIGN=2

                  DAC_SetDualChannelData PROC
;;;403      */
;;;404    void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
000000  b530              PUSH     {r4,r5,lr}
;;;405    {
;;;406      uint32_t data = 0, tmp = 0;
000002  2400              MOVS     r4,#0
000004  2300              MOVS     r3,#0
;;;407      
;;;408      /* Check the parameters */
;;;409      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;410      assert_param(IS_DAC_DATA(Data1));
;;;411      assert_param(IS_DAC_DATA(Data2));
;;;412      
;;;413      /* Calculate and set dual DAC data holding register value */
;;;414      if (DAC_Align == DAC_Align_8b_R)
000006  2808              CMP      r0,#8
000008  d102              BNE      |L9.16|
;;;415      {
;;;416        data = ((uint32_t)Data2 << 8) | Data1; 
00000a  ea422401          ORR      r4,r2,r1,LSL #8
00000e  e001              B        |L9.20|
                  |L9.16|
;;;417      }
;;;418      else
;;;419      {
;;;420        data = ((uint32_t)Data2 << 16) | Data1;
000010  ea424401          ORR      r4,r2,r1,LSL #16
                  |L9.20|
;;;421      }
;;;422      
;;;423      tmp = (uint32_t)DAC_BASE;
000014  4b02              LDR      r3,|L9.32|
;;;424      tmp += DHR12RD_Offset + DAC_Align;
000016  f1000520          ADD      r5,r0,#0x20
00001a  442b              ADD      r3,r3,r5
;;;425    
;;;426      /* Set the dual DAC selected data holding register */
;;;427      *(__IO uint32_t *)tmp = data;
00001c  601c              STR      r4,[r3,#0]
;;;428    }
00001e  bd30              POP      {r4,r5,pc}
;;;429    
                          ENDP

                  |L9.32|
                          DCD      0x40007400

                          AREA ||i.DAC_SoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_SoftwareTriggerCmd PROC
;;;267      */
;;;268    void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;269    {
;;;270      /* Check the parameters */
;;;271      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;272      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;273      if (NewState != DISABLE)
000002  b169              CBZ      r1,|L10.32|
;;;274      {
;;;275        /* Enable software trigger for the selected DAC channel */
;;;276        DAC->SWTRIGR |= SWTRIGR_SWTRIG_Set << (DAC_Channel >> 4);
000004  4a0d              LDR      r2,|L10.60|
000006  6812              LDR      r2,[r2,#0]
000008  ea4f1410          LSR      r4,r0,#4
00000c  f04f0301          MOV      r3,#1
000010  fa03f304          LSL      r3,r3,r4
000014  ea420203          ORR      r2,r2,r3
000018  4b09              LDR      r3,|L10.64|
00001a  f8c32404          STR      r2,[r3,#0x404]
00001e  e00c              B        |L10.58|
                  |L10.32|
;;;277      }
;;;278      else
;;;279      {
;;;280        /* Disable software trigger for the selected DAC channel */
;;;281        DAC->SWTRIGR &= ~(SWTRIGR_SWTRIG_Set << (DAC_Channel >> 4));
000020  4a06              LDR      r2,|L10.60|
000022  6812              LDR      r2,[r2,#0]
000024  ea4f1410          LSR      r4,r0,#4
000028  f04f0301          MOV      r3,#1
00002c  fa03f304          LSL      r3,r3,r4
000030  ea220203          BIC      r2,r2,r3
000034  4b02              LDR      r3,|L10.64|
000036  f8c32404          STR      r2,[r3,#0x404]
                  |L10.58|
;;;282      }
;;;283    }
00003a  bd10              POP      {r4,pc}
;;;284    
                          ENDP

                  |L10.60|
                          DCD      0x40007404
                  |L10.64|
                          DCD      0x40007000

                          AREA ||i.DAC_StructInit||, CODE, READONLY, ALIGN=1

                  DAC_StructInit PROC
;;;157      */
;;;158    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000000  2100              MOVS     r1,#0
;;;159    {
;;;160    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;161      /* Initialize the DAC_Trigger member */
;;;162      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
000002  6001              STR      r1,[r0,#0]
;;;163      /* Initialize the DAC_WaveGeneration member */
;;;164      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000004  6041              STR      r1,[r0,#4]
;;;165      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;166      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
000006  6081              STR      r1,[r0,#8]
;;;167      /* Initialize the DAC_OutputBuffer member */
;;;168      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000008  60c1              STR      r1,[r0,#0xc]
;;;169    }
00000a  4770              BX       lr
;;;170    
                          ENDP


                          AREA ||i.DAC_WaveGenerationCmd||, CODE, READONLY, ALIGN=2

                  DAC_WaveGenerationCmd PROC
;;;321      */
;;;322    void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;326      assert_param(IS_DAC_WAVE(DAC_Wave)); 
;;;327      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;328      if (NewState != DISABLE)
000002  b14a              CBZ      r2,|L12.24|
;;;329      {
;;;330        /* Enable the selected wave generation for the selected DAC channel */
;;;331        DAC->CR |= DAC_Wave << DAC_Channel;
000004  4b09              LDR      r3,|L12.44|
000006  681b              LDR      r3,[r3,#0]
000008  fa01f400          LSL      r4,r1,r0
00000c  ea430304          ORR      r3,r3,r4
000010  4c07              LDR      r4,|L12.48|
000012  f8c43400          STR      r3,[r4,#0x400]
000016  e008              B        |L12.42|
                  |L12.24|
;;;332      }
;;;333      else
;;;334      {
;;;335        /* Disable the selected wave generation for the selected DAC channel */
;;;336        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000018  4b04              LDR      r3,|L12.44|
00001a  681b              LDR      r3,[r3,#0]
00001c  fa01f400          LSL      r4,r1,r0
000020  ea230304          BIC      r3,r3,r4
000024  4c02              LDR      r4,|L12.48|
000026  f8c43400          STR      r3,[r4,#0x400]
                  |L12.42|
;;;337      }
;;;338    }
00002a  bd10              POP      {r4,pc}
;;;339    
                          ENDP

                  |L12.44|
                          DCD      0x40007400
                  |L12.48|
                          DCD      0x40007000
