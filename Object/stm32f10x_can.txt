; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Object\stm32f10x_can.o --depend=.\Object\stm32f10x_can.d --feedback=.\Object\stm32-speech-recognition.fed --cpu=Cortex-M3 --apcs=interwork -O0 -Otime -I.\Src\APP -I.\Src\BSP -I.\Src\GUI -I.\Src\CM3_SYS -I.\Src\FATFS -I.\Src\StdPeriph_Driver -I.\Src\StdPeriph_Driver\inc -I.\Src\Speech_Recog -IE:\SoftWare\KEIL\Keil4\path\ARM\INC -IE:\SoftWare\KEIL\Keil4\path\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\Object\stm32f10x_can.crf Src\StdPeriph_Driver\src\stm32f10x_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=1

                  CAN_CancelTransmit PROC
;;;604      */
;;;605    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b121              CBZ      r1,|L1.12|
;;;606    {
;;;607      /* Check the parameters */
;;;608      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;609      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;610      /* abort transmission */
;;;611      switch (Mailbox)
000002  2901              CMP      r1,#1
000004  d007              BEQ      |L1.22|
000006  2902              CMP      r1,#2
000008  d10f              BNE      |L1.42|
00000a  e009              B        |L1.32|
                  |L1.12|
;;;612      {
;;;613        case (0): CANx->TSR |= TSR_ABRQ0;
00000c  6882              LDR      r2,[r0,#8]
00000e  f0420280          ORR      r2,r2,#0x80
000012  6082              STR      r2,[r0,#8]
;;;614          break;
000014  e00a              B        |L1.44|
                  |L1.22|
;;;615        case (1): CANx->TSR |= TSR_ABRQ1;
000016  6882              LDR      r2,[r0,#8]
000018  f4424200          ORR      r2,r2,#0x8000
00001c  6082              STR      r2,[r0,#8]
;;;616          break;
00001e  e005              B        |L1.44|
                  |L1.32|
;;;617        case (2): CANx->TSR |= TSR_ABRQ2;
000020  6882              LDR      r2,[r0,#8]
000022  f4420200          ORR      r2,r2,#0x800000
000026  6082              STR      r2,[r0,#8]
;;;618          break;
000028  e000              B        |L1.44|
                  |L1.42|
;;;619        default:
;;;620          break;
00002a  bf00              NOP      
                  |L1.44|
00002c  bf00              NOP                            ;614
;;;621      }
;;;622    }
00002e  4770              BX       lr
;;;623    
                          ENDP


                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=1

                  CAN_ClearFlag PROC
;;;829      */
;;;830    void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  6982              LDR      r2,[r0,#0x18]
;;;831    {
;;;832      /* Check the parameters */
;;;833      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;834      assert_param(IS_CAN_FLAG(CAN_FLAG));
;;;835      /* Clear the selected CAN flags */
;;;836      CANx->ESR &= ~CAN_FLAG;
000002  438a              BICS     r2,r2,r1
000004  6182              STR      r2,[r0,#0x18]
;;;837    }
000006  4770              BX       lr
;;;838    
                          ENDP


                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  CAN_ClearITPendingBit PROC
;;;906      */
;;;907    void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  2940              CMP      r1,#0x40
;;;908    {
;;;909      /* Check the parameters */
;;;910      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;911      assert_param(IS_CAN_ITStatus(CAN_IT));
;;;912      switch (CAN_IT)
000002  d035              BEQ      |L3.112|
000004  dc0e              BGT      |L3.36|
000006  2907              CMP      r1,#7
000008  d025              BEQ      |L3.86|
00000a  dc06              BGT      |L3.26|
00000c  2904              CMP      r1,#4
00000e  d026              BEQ      |L3.94|
000010  2905              CMP      r1,#5
000012  d019              BEQ      |L3.72|
000014  2906              CMP      r1,#6
000016  d143              BNE      |L3.160|
000018  e019              B        |L3.78|
                  |L3.26|
00001a  2908              CMP      r1,#8
00001c  d022              BEQ      |L3.100|
00001e  2920              CMP      r1,#0x20
000020  d13e              BNE      |L3.160|
000022  e022              B        |L3.106|
                  |L3.36|
000024  f5b16f80          CMP      r1,#0x400
000028  d02f              BEQ      |L3.138|
00002a  dc06              BGT      |L3.58|
00002c  f5b17f80          CMP      r1,#0x100
000030  d021              BEQ      |L3.118|
000032  f5b17f00          CMP      r1,#0x200
000036  d133              BNE      |L3.160|
000038  e022              B        |L3.128|
                  |L3.58|
00003a  f5b13f80          CMP      r1,#0x10000
00003e  d029              BEQ      |L3.148|
000040  f5b13f00          CMP      r1,#0x20000
000044  d12c              BNE      |L3.160|
000046  e028              B        |L3.154|
                  |L3.72|
;;;913      {
;;;914        case CAN_IT_RQCP0:
;;;915          CANx->TSR = TSR_RQCP0; /* rc_w1*/
000048  2201              MOVS     r2,#1
00004a  6082              STR      r2,[r0,#8]
;;;916          break;
00004c  e029              B        |L3.162|
                  |L3.78|
;;;917        case CAN_IT_RQCP1:
;;;918          CANx->TSR = TSR_RQCP1; /* rc_w1*/
00004e  f44f7280          MOV      r2,#0x100
000052  6082              STR      r2,[r0,#8]
;;;919          break;
000054  e025              B        |L3.162|
                  |L3.86|
;;;920        case CAN_IT_RQCP2:
;;;921          CANx->TSR = TSR_RQCP2; /* rc_w1*/
000056  f44f3280          MOV      r2,#0x10000
00005a  6082              STR      r2,[r0,#8]
;;;922          break;
00005c  e021              B        |L3.162|
                  |L3.94|
;;;923        case CAN_IT_FF0:
;;;924          CANx->RF0R = RF0R_FULL0; /* rc_w1*/
00005e  2208              MOVS     r2,#8
000060  60c2              STR      r2,[r0,#0xc]
;;;925          break;
000062  e01e              B        |L3.162|
                  |L3.100|
;;;926        case CAN_IT_FOV0:
;;;927          CANx->RF0R = RF0R_FOVR0; /* rc_w1*/
000064  2210              MOVS     r2,#0x10
000066  60c2              STR      r2,[r0,#0xc]
;;;928          break;
000068  e01b              B        |L3.162|
                  |L3.106|
;;;929        case CAN_IT_FF1:
;;;930          CANx->RF1R = RF1R_FULL1; /* rc_w1*/
00006a  2208              MOVS     r2,#8
00006c  6102              STR      r2,[r0,#0x10]
;;;931          break;
00006e  e018              B        |L3.162|
                  |L3.112|
;;;932        case CAN_IT_FOV1:
;;;933          CANx->RF1R = RF1R_FOVR1; /* rc_w1*/
000070  2210              MOVS     r2,#0x10
000072  6102              STR      r2,[r0,#0x10]
;;;934          break;
000074  e015              B        |L3.162|
                  |L3.118|
;;;935        case CAN_IT_EWG:
;;;936          CANx->ESR &= ~ ESR_EWGF; /* rw */
000076  6982              LDR      r2,[r0,#0x18]
000078  f0220201          BIC      r2,r2,#1
00007c  6182              STR      r2,[r0,#0x18]
;;;937          break;
00007e  e010              B        |L3.162|
                  |L3.128|
;;;938        case CAN_IT_EPV:
;;;939          CANx->ESR &= ~ ESR_EPVF; /* rw */
000080  6982              LDR      r2,[r0,#0x18]
000082  f0220202          BIC      r2,r2,#2
000086  6182              STR      r2,[r0,#0x18]
;;;940          break;
000088  e00b              B        |L3.162|
                  |L3.138|
;;;941        case CAN_IT_BOF:
;;;942          CANx->ESR &= ~ ESR_BOFF; /* rw */
00008a  6982              LDR      r2,[r0,#0x18]
00008c  f0220204          BIC      r2,r2,#4
000090  6182              STR      r2,[r0,#0x18]
;;;943          break;
000092  e006              B        |L3.162|
                  |L3.148|
;;;944        case CAN_IT_WKU:
;;;945          CANx->MSR = MSR_WKUI;  /* rc_w1*/
000094  2208              MOVS     r2,#8
000096  6042              STR      r2,[r0,#4]
;;;946          break;
000098  e003              B        |L3.162|
                  |L3.154|
;;;947        case CAN_IT_SLK:
;;;948          CANx->MSR = MSR_SLAKI;  /* rc_w1*/
00009a  2210              MOVS     r2,#0x10
00009c  6042              STR      r2,[r0,#4]
;;;949          break;
00009e  e000              B        |L3.162|
                  |L3.160|
;;;950        default :
;;;951          break;
0000a0  bf00              NOP      
                  |L3.162|
0000a2  bf00              NOP                            ;916
;;;952      }
;;;953    }
0000a4  4770              BX       lr
;;;954    
                          ENDP


                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=1

                  CAN_DBGFreeze PROC
;;;722      */
;;;723    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;724    {
;;;725      /* Check the parameters */
;;;726      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;727      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;728      
;;;729      if (NewState != DISABLE)
;;;730      {
;;;731        /* Enable Debug Freeze  */
;;;732        CANx->MCR |= MCR_DBF;
000002  6802              LDR      r2,[r0,#0]
000004  f4423280          ORR      r2,r2,#0x10000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;733      }
;;;734      else
;;;735      {
;;;736        /* Disable Debug Freeze */
;;;737        CANx->MCR &= ~MCR_DBF;
00000c  6802              LDR      r2,[r0,#0]
00000e  f4223280          BIC      r2,r2,#0x10000
000012  6002              STR      r2,[r0,#0]
                  |L4.20|
;;;738      }
;;;739    }
000014  4770              BX       lr
;;;740    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;142      */
;;;143    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;144    {
000002  4604              MOV      r4,r0
;;;145      /* Check the parameters */
;;;146      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;147     
;;;148      if (CANx == CAN1)
000004  480b              LDR      r0,|L5.52|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L5.30|
;;;149      {
;;;150        /* Enable CAN1 reset state */
;;;151        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0648              LSLS     r0,r1,#25
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;152        /* Release CAN1 from reset state */
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f04f7000          MOV      r0,#0x2000000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L5.48|
                  |L5.30|
;;;154      }
;;;155      else
;;;156      {  
;;;157        /* Enable CAN2 reset state */
;;;158        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0688              LSLS     r0,r1,#26
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159        /* Release CAN2 from reset state */
;;;160        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
000026  2100              MOVS     r1,#0
000028  f04f6080          MOV      r0,#0x4000000
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.48|
;;;161      }
;;;162    }
000030  bd10              POP      {r4,pc}
;;;163    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40006400

                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=1

                  CAN_FIFORelease PROC
;;;629      */
;;;630    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b911              CBNZ     r1,|L6.8|
;;;631    {
;;;632      /* Check the parameters */
;;;633      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;634      assert_param(IS_CAN_FIFO(FIFONumber));
;;;635      /* Release FIFO0 */
;;;636      if (FIFONumber == CAN_FIFO0)
;;;637      {
;;;638        CANx->RF0R = RF0R_RFOM0;
000002  2220              MOVS     r2,#0x20
000004  60c2              STR      r2,[r0,#0xc]
000006  e001              B        |L6.12|
                  |L6.8|
;;;639      }
;;;640      /* Release FIFO1 */
;;;641      else /* FIFONumber == CAN_FIFO1 */
;;;642      {
;;;643        CANx->RF1R = RF1R_RFOM1;
000008  2220              MOVS     r2,#0x20
00000a  6102              STR      r2,[r0,#0x10]
                  |L6.12|
;;;644      }
;;;645    }
00000c  4770              BX       lr
;;;646    
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;307      */
;;;308    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b510              PUSH     {r4,lr}
;;;309    {
;;;310      uint32_t filter_number_bit_pos = 0;
000002  2100              MOVS     r1,#0
;;;311      /* Check the parameters */
;;;312      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;313      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;314      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;315      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;316      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;317    
;;;318      filter_number_bit_pos = ((uint32_t)0x00000001) << CAN_FilterInitStruct->CAN_FilterNumber;
000004  7a83              LDRB     r3,[r0,#0xa]
000006  2201              MOVS     r2,#1
000008  fa02f103          LSL      r1,r2,r3
;;;319    
;;;320      /* Initialisation mode for the filter */
;;;321      CAN1->FMR |= FMR_FINIT;
00000c  4a3b              LDR      r2,|L7.252|
00000e  6812              LDR      r2,[r2,#0]
000010  f0420201          ORR      r2,r2,#1
000014  4b3a              LDR      r3,|L7.256|
000016  f8c32600          STR      r2,[r3,#0x600]
;;;322    
;;;323      /* Filter Deactivation */
;;;324      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
00001a  461a              MOV      r2,r3
00001c  f8d2261c          LDR      r2,[r2,#0x61c]
000020  ea220201          BIC      r2,r2,r1
000024  4b37              LDR      r3,|L7.260|
000026  601a              STR      r2,[r3,#0]
;;;325    
;;;326      /* Filter Scale */
;;;327      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
000028  7b02              LDRB     r2,[r0,#0xc]
00002a  b9b2              CBNZ     r2,|L7.90|
;;;328      {
;;;329        /* 16-bit scale for the filter */
;;;330        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
00002c  4a36              LDR      r2,|L7.264|
00002e  6812              LDR      r2,[r2,#0]
000030  ea220201          BIC      r2,r2,r1
000034  4b34              LDR      r3,|L7.264|
000036  601a              STR      r2,[r3,#0]
;;;331    
;;;332        /* First 16-bit identifier and First 16-bit mask */
;;;333        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;334        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000038  8842              LDRH     r2,[r0,#2]
00003a  88c3              LDRH     r3,[r0,#6]
00003c  ea424303          ORR      r3,r2,r3,LSL #16
000040  4a32              LDR      r2,|L7.268|
000042  7a84              LDRB     r4,[r0,#0xa]
000044  f8423034          STR      r3,[r2,r4,LSL #3]
;;;335        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;336            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;337    
;;;338        /* Second 16-bit identifier and Second 16-bit mask */
;;;339        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;340        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
000048  8802              LDRH     r2,[r0,#0]
00004a  8883              LDRH     r3,[r0,#4]
00004c  ea424303          ORR      r3,r2,r3,LSL #16
000050  4a2e              LDR      r2,|L7.268|
000052  7a84              LDRB     r4,[r0,#0xa]
000054  eb0202c4          ADD      r2,r2,r4,LSL #3
000058  6053              STR      r3,[r2,#4]
                  |L7.90|
;;;341        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;342            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;343      }
;;;344    
;;;345      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
00005a  7b02              LDRB     r2,[r0,#0xc]
00005c  2a01              CMP      r2,#1
00005e  d116              BNE      |L7.142|
;;;346      {
;;;347        /* 32-bit scale for the filter */
;;;348        CAN1->FS1R |= filter_number_bit_pos;
000060  4a29              LDR      r2,|L7.264|
000062  6812              LDR      r2,[r2,#0]
000064  ea420201          ORR      r2,r2,r1
000068  4b27              LDR      r3,|L7.264|
00006a  601a              STR      r2,[r3,#0]
;;;349        /* 32-bit identifier or First 32-bit identifier */
;;;350        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00006c  8842              LDRH     r2,[r0,#2]
00006e  8803              LDRH     r3,[r0,#0]
000070  ea424303          ORR      r3,r2,r3,LSL #16
000074  4a25              LDR      r2,|L7.268|
000076  7a84              LDRB     r4,[r0,#0xa]
000078  f8423034          STR      r3,[r2,r4,LSL #3]
;;;351        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;352            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;353        /* 32-bit mask or Second 32-bit identifier */
;;;354        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00007c  88c2              LDRH     r2,[r0,#6]
00007e  8883              LDRH     r3,[r0,#4]
000080  ea424303          ORR      r3,r2,r3,LSL #16
000084  4a21              LDR      r2,|L7.268|
000086  7a84              LDRB     r4,[r0,#0xa]
000088  eb0202c4          ADD      r2,r2,r4,LSL #3
00008c  6053              STR      r3,[r2,#4]
                  |L7.142|
;;;355        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;356            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;357      }
;;;358    
;;;359      /* Filter Mode */
;;;360      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
00008e  7ac2              LDRB     r2,[r0,#0xb]
000090  b93a              CBNZ     r2,|L7.162|
;;;361      {
;;;362        /*Id/Mask mode for the filter*/
;;;363        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
000092  4a1f              LDR      r2,|L7.272|
000094  6812              LDR      r2,[r2,#0]
000096  ea220201          BIC      r2,r2,r1
00009a  4b19              LDR      r3,|L7.256|
00009c  f8c32604          STR      r2,[r3,#0x604]
0000a0  e006              B        |L7.176|
                  |L7.162|
;;;364      }
;;;365      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;366      {
;;;367        /*Identifier list mode for the filter*/
;;;368        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
0000a2  4a1b              LDR      r2,|L7.272|
0000a4  6812              LDR      r2,[r2,#0]
0000a6  ea420201          ORR      r2,r2,r1
0000aa  4b15              LDR      r3,|L7.256|
0000ac  f8c32604          STR      r2,[r3,#0x604]
                  |L7.176|
;;;369      }
;;;370    
;;;371      /* Filter FIFO assignment */
;;;372      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
0000b0  8902              LDRH     r2,[r0,#8]
0000b2  b932              CBNZ     r2,|L7.194|
;;;373      {
;;;374        /* FIFO 0 assignation for the filter */
;;;375        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
0000b4  4a17              LDR      r2,|L7.276|
0000b6  6812              LDR      r2,[r2,#0]
0000b8  ea220201          BIC      r2,r2,r1
0000bc  4b10              LDR      r3,|L7.256|
0000be  f8c32614          STR      r2,[r3,#0x614]
                  |L7.194|
;;;376      }
;;;377    
;;;378      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
0000c2  8902              LDRH     r2,[r0,#8]
0000c4  2a01              CMP      r2,#1
0000c6  d106              BNE      |L7.214|
;;;379      {
;;;380        /* FIFO 1 assignation for the filter */
;;;381        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0000c8  4a12              LDR      r2,|L7.276|
0000ca  6812              LDR      r2,[r2,#0]
0000cc  ea420201          ORR      r2,r2,r1
0000d0  4b0b              LDR      r3,|L7.256|
0000d2  f8c32614          STR      r2,[r3,#0x614]
                  |L7.214|
;;;382      }
;;;383      
;;;384      /* Filter activation */
;;;385      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0000d6  7b42              LDRB     r2,[r0,#0xd]
0000d8  2a01              CMP      r2,#1
0000da  d106              BNE      |L7.234|
;;;386      {
;;;387        CAN1->FA1R |= filter_number_bit_pos;
0000dc  4a09              LDR      r2,|L7.260|
0000de  6812              LDR      r2,[r2,#0]
0000e0  ea420201          ORR      r2,r2,r1
0000e4  4b06              LDR      r3,|L7.256|
0000e6  f8c3261c          STR      r2,[r3,#0x61c]
                  |L7.234|
;;;388      }
;;;389    
;;;390      /* Leave the initialisation mode for the filter */
;;;391      CAN1->FMR &= ~FMR_FINIT;
0000ea  4a04              LDR      r2,|L7.252|
0000ec  6812              LDR      r2,[r2,#0]
0000ee  f0220201          BIC      r2,r2,#1
0000f2  4b03              LDR      r3,|L7.256|
0000f4  f8c32600          STR      r2,[r3,#0x600]
;;;392    }
0000f8  bd10              POP      {r4,pc}
;;;393    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L7.252|
                          DCD      0x40006600
                  |L7.256|
                          DCD      0x40006000
                  |L7.260|
                          DCD      0x4000661c
                  |L7.264|
                          DCD      0x4000660c
                  |L7.268|
                          DCD      0x40006640
                  |L7.272|
                          DCD      0x40006604
                  |L7.276|
                          DCD      0x40006614

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetFlagStatus PROC
;;;802      */
;;;803    FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4602              MOV      r2,r0
;;;804    {
;;;805      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;806      /* Check the parameters */
;;;807      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;808      assert_param(IS_CAN_FLAG(CAN_FLAG));
;;;809      /* Check the status of the specified CAN flag */
;;;810      if ((CANx->ESR & CAN_FLAG) != (uint32_t)RESET)
000004  6993              LDR      r3,[r2,#0x18]
000006  420b              TST      r3,r1
000008  d001              BEQ      |L8.14|
;;;811      {
;;;812        /* CAN_FLAG is set */
;;;813        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L8.16|
                  |L8.14|
;;;814      }
;;;815      else
;;;816      {
;;;817        /* CAN_FLAG is reset */
;;;818        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L8.16|
;;;819      }
;;;820      /* Return the CAN_FLAG status */
;;;821      return  bitstatus;
;;;822    }
000010  4770              BX       lr
;;;823    
                          ENDP


                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetITStatus PROC
;;;848      */
;;;849    ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;850    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;851      ITStatus pendingbitstatus = RESET;
000006  2600              MOVS     r6,#0
;;;852      /* Check the parameters */
;;;853      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;854      assert_param(IS_CAN_ITStatus(CAN_IT));
;;;855      switch (CAN_IT)
000008  2d40              CMP      r5,#0x40
00000a  d047              BEQ      |L9.156|
00000c  dc0e              BGT      |L9.44|
00000e  2d07              CMP      r5,#7
000010  d02b              BEQ      |L9.106|
000012  dc06              BGT      |L9.34|
000014  2d04              CMP      r5,#4
000016  d02f              BEQ      |L9.120|
000018  2d05              CMP      r5,#5
00001a  d019              BEQ      |L9.80|
00001c  2d06              CMP      r5,#6
00001e  d161              BNE      |L9.228|
000020  e01c              B        |L9.92|
                  |L9.34|
000022  2d08              CMP      r5,#8
000024  d02e              BEQ      |L9.132|
000026  2d20              CMP      r5,#0x20
000028  d15c              BNE      |L9.228|
00002a  e031              B        |L9.144|
                  |L9.44|
00002c  f5b56f80          CMP      r5,#0x400
000030  d046              BEQ      |L9.192|
000032  dc06              BGT      |L9.66|
000034  f5b57f80          CMP      r5,#0x100
000038  d036              BEQ      |L9.168|
00003a  f5b57f00          CMP      r5,#0x200
00003e  d151              BNE      |L9.228|
000040  e038              B        |L9.180|
                  |L9.66|
000042  f5b53f80          CMP      r5,#0x10000
000046  d047              BEQ      |L9.216|
000048  f5b53f00          CMP      r5,#0x20000
00004c  d14a              BNE      |L9.228|
00004e  e03d              B        |L9.204|
                  |L9.80|
;;;856      {
;;;857        case CAN_IT_RQCP0:
;;;858          pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP0);
000050  68a0              LDR      r0,[r4,#8]
000052  2101              MOVS     r1,#1
000054  f7fffffe          BL       CheckITStatus
000058  4606              MOV      r6,r0
;;;859          break;
00005a  e045              B        |L9.232|
                  |L9.92|
;;;860        case CAN_IT_RQCP1:
;;;861          pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP1);
00005c  68a0              LDR      r0,[r4,#8]
00005e  f44f7180          MOV      r1,#0x100
000062  f7fffffe          BL       CheckITStatus
000066  4606              MOV      r6,r0
;;;862          break;
000068  e03e              B        |L9.232|
                  |L9.106|
;;;863        case CAN_IT_RQCP2:
;;;864          pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP2);
00006a  68a0              LDR      r0,[r4,#8]
00006c  f44f3180          MOV      r1,#0x10000
000070  f7fffffe          BL       CheckITStatus
000074  4606              MOV      r6,r0
;;;865          break;
000076  e037              B        |L9.232|
                  |L9.120|
;;;866        case CAN_IT_FF0:
;;;867          pendingbitstatus = CheckITStatus(CANx->RF0R, RF0R_FULL0);
000078  68e0              LDR      r0,[r4,#0xc]
00007a  2108              MOVS     r1,#8
00007c  f7fffffe          BL       CheckITStatus
000080  4606              MOV      r6,r0
;;;868          break;
000082  e031              B        |L9.232|
                  |L9.132|
;;;869        case CAN_IT_FOV0:
;;;870          pendingbitstatus = CheckITStatus(CANx->RF0R, RF0R_FOVR0);
000084  68e0              LDR      r0,[r4,#0xc]
000086  2110              MOVS     r1,#0x10
000088  f7fffffe          BL       CheckITStatus
00008c  4606              MOV      r6,r0
;;;871          break;
00008e  e02b              B        |L9.232|
                  |L9.144|
;;;872        case CAN_IT_FF1:
;;;873          pendingbitstatus = CheckITStatus(CANx->RF1R, RF1R_FULL1);
000090  6920              LDR      r0,[r4,#0x10]
000092  2108              MOVS     r1,#8
000094  f7fffffe          BL       CheckITStatus
000098  4606              MOV      r6,r0
;;;874          break;
00009a  e025              B        |L9.232|
                  |L9.156|
;;;875        case CAN_IT_FOV1:
;;;876          pendingbitstatus = CheckITStatus(CANx->RF1R, RF1R_FOVR1);
00009c  6920              LDR      r0,[r4,#0x10]
00009e  2110              MOVS     r1,#0x10
0000a0  f7fffffe          BL       CheckITStatus
0000a4  4606              MOV      r6,r0
;;;877          break;
0000a6  e01f              B        |L9.232|
                  |L9.168|
;;;878        case CAN_IT_EWG:
;;;879          pendingbitstatus = CheckITStatus(CANx->ESR, ESR_EWGF);
0000a8  69a0              LDR      r0,[r4,#0x18]
0000aa  2101              MOVS     r1,#1
0000ac  f7fffffe          BL       CheckITStatus
0000b0  4606              MOV      r6,r0
;;;880          break;
0000b2  e019              B        |L9.232|
                  |L9.180|
;;;881        case CAN_IT_EPV:
;;;882          pendingbitstatus = CheckITStatus(CANx->ESR, ESR_EPVF);
0000b4  69a0              LDR      r0,[r4,#0x18]
0000b6  2102              MOVS     r1,#2
0000b8  f7fffffe          BL       CheckITStatus
0000bc  4606              MOV      r6,r0
;;;883          break;
0000be  e013              B        |L9.232|
                  |L9.192|
;;;884        case CAN_IT_BOF:
;;;885          pendingbitstatus = CheckITStatus(CANx->ESR, ESR_BOFF);
0000c0  69a0              LDR      r0,[r4,#0x18]
0000c2  2104              MOVS     r1,#4
0000c4  f7fffffe          BL       CheckITStatus
0000c8  4606              MOV      r6,r0
;;;886          break;
0000ca  e00d              B        |L9.232|
                  |L9.204|
;;;887        case CAN_IT_SLK:
;;;888          pendingbitstatus = CheckITStatus(CANx->MSR, MSR_SLAKI);
0000cc  6860              LDR      r0,[r4,#4]
0000ce  2110              MOVS     r1,#0x10
0000d0  f7fffffe          BL       CheckITStatus
0000d4  4606              MOV      r6,r0
;;;889          break;
0000d6  e007              B        |L9.232|
                  |L9.216|
;;;890        case CAN_IT_WKU:
;;;891          pendingbitstatus = CheckITStatus(CANx->MSR, MSR_WKUI);
0000d8  6860              LDR      r0,[r4,#4]
0000da  2108              MOVS     r1,#8
0000dc  f7fffffe          BL       CheckITStatus
0000e0  4606              MOV      r6,r0
;;;892          break;
0000e2  e001              B        |L9.232|
                  |L9.228|
;;;893        default :
;;;894          pendingbitstatus = RESET;
0000e4  2600              MOVS     r6,#0
;;;895          break;
0000e6  bf00              NOP      
                  |L9.232|
0000e8  bf00              NOP                            ;859
;;;896      }
;;;897      /* Return the CAN_IT status */
;;;898      return  pendingbitstatus;
0000ea  4630              MOV      r0,r6
;;;899    }
0000ec  bd70              POP      {r4-r6,pc}
;;;900    
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;458      */
;;;459    void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L10.10|
;;;460    {
;;;461      /* Check the parameters */
;;;462      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;463      assert_param(IS_CAN_ITConfig(CAN_IT));
;;;464      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;465    
;;;466      if (NewState != DISABLE)
;;;467      {
;;;468        /* Enable the selected CAN interrupt */
;;;469        CANx->IER |= CAN_IT;
000002  6943              LDR      r3,[r0,#0x14]
000004  430b              ORRS     r3,r3,r1
000006  6143              STR      r3,[r0,#0x14]
000008  e002              B        |L10.16|
                  |L10.10|
;;;470      }
;;;471      else
;;;472      {
;;;473        /* Disable the selected CAN interrupt */
;;;474        CANx->IER &= ~CAN_IT;
00000a  6943              LDR      r3,[r0,#0x14]
00000c  438b              BICS     r3,r3,r1
00000e  6143              STR      r3,[r0,#0x14]
                  |L10.16|
;;;475      }
;;;476    }
000010  4770              BX       lr
;;;477    
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;172      */
;;;173    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;174    {
000002  4602              MOV      r2,r0
;;;175      uint8_t InitStatus = CANINITFAILED;
000004  2000              MOVS     r0,#0
;;;176      uint32_t wait_ack = 0x00000000;
000006  2300              MOVS     r3,#0
;;;177      /* Check the parameters */
;;;178      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;179      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;180      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;181      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;182      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;183      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;184      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;185      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;186      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;187      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;188      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;189      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;190    
;;;191      /* exit from sleep mode */
;;;192      CANx->MCR &= ~MCR_SLEEP;
000008  6814              LDR      r4,[r2,#0]
00000a  f0240402          BIC      r4,r4,#2
00000e  6014              STR      r4,[r2,#0]
;;;193    
;;;194      /* Request initialisation */
;;;195      CANx->MCR |= MCR_INRQ ;
000010  6814              LDR      r4,[r2,#0]
000012  f0440401          ORR      r4,r4,#1
000016  6014              STR      r4,[r2,#0]
;;;196    
;;;197      /* Wait the acknowledge */
;;;198      while (((CANx->MSR & MSR_INAK) != MSR_INAK) && (wait_ack != INAK_TimeOut))
000018  e000              B        |L11.28|
                  |L11.26|
;;;199      {
;;;200        wait_ack++;
00001a  1c5b              ADDS     r3,r3,#1
                  |L11.28|
00001c  6854              LDR      r4,[r2,#4]            ;198
00001e  f0040401          AND      r4,r4,#1              ;198
000022  2c01              CMP      r4,#1                 ;198
000024  d003              BEQ      |L11.46|
000026  f5a3447f          SUB      r4,r3,#0xff00         ;198
00002a  3cff              SUBS     r4,r4,#0xff           ;198
00002c  d1f5              BNE      |L11.26|
                  |L11.46|
;;;201      }
;;;202    
;;;203      /* ...and check acknowledged */
;;;204      if ((CANx->MSR & MSR_INAK) != MSR_INAK)
00002e  6854              LDR      r4,[r2,#4]
000030  f0040401          AND      r4,r4,#1
000034  2c01              CMP      r4,#1
000036  d001              BEQ      |L11.60|
;;;205      {
;;;206        InitStatus = CANINITFAILED;
000038  2000              MOVS     r0,#0
00003a  e06e              B        |L11.282|
                  |L11.60|
;;;207      }
;;;208      else 
;;;209      {
;;;210        /* Set the time triggered communication mode */
;;;211        if (CAN_InitStruct->CAN_TTCM == ENABLE)
00003c  798c              LDRB     r4,[r1,#6]
00003e  2c01              CMP      r4,#1
000040  d104              BNE      |L11.76|
;;;212        {
;;;213          CANx->MCR |= MCR_TTCM;
000042  6814              LDR      r4,[r2,#0]
000044  f0440480          ORR      r4,r4,#0x80
000048  6014              STR      r4,[r2,#0]
00004a  e003              B        |L11.84|
                  |L11.76|
;;;214        }
;;;215        else
;;;216        {
;;;217          CANx->MCR &= ~MCR_TTCM;
00004c  6814              LDR      r4,[r2,#0]
00004e  f0240480          BIC      r4,r4,#0x80
000052  6014              STR      r4,[r2,#0]
                  |L11.84|
;;;218        }
;;;219    
;;;220        /* Set the automatic bus-off management */
;;;221        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000054  79cc              LDRB     r4,[r1,#7]
000056  2c01              CMP      r4,#1
000058  d104              BNE      |L11.100|
;;;222        {
;;;223          CANx->MCR |= MCR_ABOM;
00005a  6814              LDR      r4,[r2,#0]
00005c  f0440440          ORR      r4,r4,#0x40
000060  6014              STR      r4,[r2,#0]
000062  e003              B        |L11.108|
                  |L11.100|
;;;224        }
;;;225        else
;;;226        {
;;;227          CANx->MCR &= ~MCR_ABOM;
000064  6814              LDR      r4,[r2,#0]
000066  f0240440          BIC      r4,r4,#0x40
00006a  6014              STR      r4,[r2,#0]
                  |L11.108|
;;;228        }
;;;229    
;;;230        /* Set the automatic wake-up mode */
;;;231        if (CAN_InitStruct->CAN_AWUM == ENABLE)
00006c  7a0c              LDRB     r4,[r1,#8]
00006e  2c01              CMP      r4,#1
000070  d104              BNE      |L11.124|
;;;232        {
;;;233          CANx->MCR |= MCR_AWUM;
000072  6814              LDR      r4,[r2,#0]
000074  f0440420          ORR      r4,r4,#0x20
000078  6014              STR      r4,[r2,#0]
00007a  e003              B        |L11.132|
                  |L11.124|
;;;234        }
;;;235        else
;;;236        {
;;;237          CANx->MCR &= ~MCR_AWUM;
00007c  6814              LDR      r4,[r2,#0]
00007e  f0240420          BIC      r4,r4,#0x20
000082  6014              STR      r4,[r2,#0]
                  |L11.132|
;;;238        }
;;;239    
;;;240        /* Set the no automatic retransmission */
;;;241        if (CAN_InitStruct->CAN_NART == ENABLE)
000084  7a4c              LDRB     r4,[r1,#9]
000086  2c01              CMP      r4,#1
000088  d104              BNE      |L11.148|
;;;242        {
;;;243          CANx->MCR |= MCR_NART;
00008a  6814              LDR      r4,[r2,#0]
00008c  f0440410          ORR      r4,r4,#0x10
000090  6014              STR      r4,[r2,#0]
000092  e003              B        |L11.156|
                  |L11.148|
;;;244        }
;;;245        else
;;;246        {
;;;247          CANx->MCR &= ~MCR_NART;
000094  6814              LDR      r4,[r2,#0]
000096  f0240410          BIC      r4,r4,#0x10
00009a  6014              STR      r4,[r2,#0]
                  |L11.156|
;;;248        }
;;;249    
;;;250        /* Set the receive FIFO locked mode */
;;;251        if (CAN_InitStruct->CAN_RFLM == ENABLE)
00009c  7a8c              LDRB     r4,[r1,#0xa]
00009e  2c01              CMP      r4,#1
0000a0  d104              BNE      |L11.172|
;;;252        {
;;;253          CANx->MCR |= MCR_RFLM;
0000a2  6814              LDR      r4,[r2,#0]
0000a4  f0440408          ORR      r4,r4,#8
0000a8  6014              STR      r4,[r2,#0]
0000aa  e003              B        |L11.180|
                  |L11.172|
;;;254        }
;;;255        else
;;;256        {
;;;257          CANx->MCR &= ~MCR_RFLM;
0000ac  6814              LDR      r4,[r2,#0]
0000ae  f0240408          BIC      r4,r4,#8
0000b2  6014              STR      r4,[r2,#0]
                  |L11.180|
;;;258        }
;;;259    
;;;260        /* Set the transmit FIFO priority */
;;;261        if (CAN_InitStruct->CAN_TXFP == ENABLE)
0000b4  7acc              LDRB     r4,[r1,#0xb]
0000b6  2c01              CMP      r4,#1
0000b8  d104              BNE      |L11.196|
;;;262        {
;;;263          CANx->MCR |= MCR_TXFP;
0000ba  6814              LDR      r4,[r2,#0]
0000bc  f0440404          ORR      r4,r4,#4
0000c0  6014              STR      r4,[r2,#0]
0000c2  e003              B        |L11.204|
                  |L11.196|
;;;264        }
;;;265        else
;;;266        {
;;;267          CANx->MCR &= ~MCR_TXFP;
0000c4  6814              LDR      r4,[r2,#0]
0000c6  f0240404          BIC      r4,r4,#4
0000ca  6014              STR      r4,[r2,#0]
                  |L11.204|
;;;268        }
;;;269    
;;;270        /* Set the bit timing register */
;;;271        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | ((uint32_t)CAN_InitStruct->CAN_SJW << 24) |
0000cc  788c              LDRB     r4,[r1,#2]
0000ce  07a4              LSLS     r4,r4,#30
0000d0  78cd              LDRB     r5,[r1,#3]
0000d2  ea446405          ORR      r4,r4,r5,LSL #24
0000d6  790d              LDRB     r5,[r1,#4]
0000d8  ea444405          ORR      r4,r4,r5,LSL #16
0000dc  794d              LDRB     r5,[r1,#5]
0000de  ea445405          ORR      r4,r4,r5,LSL #20
0000e2  880d              LDRH     r5,[r1,#0]
0000e4  1e6d              SUBS     r5,r5,#1
0000e6  432c              ORRS     r4,r4,r5
0000e8  61d4              STR      r4,[r2,#0x1c]
;;;272                   ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) |
;;;273                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;274    
;;;275        /* Request leave initialisation */
;;;276        CANx->MCR &= ~MCR_INRQ;
0000ea  6814              LDR      r4,[r2,#0]
0000ec  f0240401          BIC      r4,r4,#1
0000f0  6014              STR      r4,[r2,#0]
;;;277    
;;;278       /* Wait the acknowledge */
;;;279       wait_ack = 0x00;
0000f2  2300              MOVS     r3,#0
;;;280    
;;;281       while (((CANx->MSR & MSR_INAK) == MSR_INAK) && (wait_ack != INAK_TimeOut))
0000f4  e000              B        |L11.248|
                  |L11.246|
;;;282       {
;;;283         wait_ack++;
0000f6  1c5b              ADDS     r3,r3,#1
                  |L11.248|
0000f8  6854              LDR      r4,[r2,#4]            ;281
0000fa  f0040401          AND      r4,r4,#1              ;281
0000fe  2c01              CMP      r4,#1                 ;281
000100  d103              BNE      |L11.266|
000102  f5a3447f          SUB      r4,r3,#0xff00         ;281
000106  3cff              SUBS     r4,r4,#0xff           ;281
000108  d1f5              BNE      |L11.246|
                  |L11.266|
;;;284       }
;;;285    
;;;286        /* ...and check acknowledged */
;;;287        if ((CANx->MSR & MSR_INAK) == MSR_INAK)
00010a  6854              LDR      r4,[r2,#4]
00010c  f0040401          AND      r4,r4,#1
000110  2c01              CMP      r4,#1
000112  d101              BNE      |L11.280|
;;;288        {
;;;289          InitStatus = CANINITFAILED;
000114  2000              MOVS     r0,#0
000116  e000              B        |L11.282|
                  |L11.280|
;;;290        }
;;;291        else
;;;292        {
;;;293          InitStatus = CANINITOK ;
000118  2001              MOVS     r0,#1
                  |L11.282|
;;;294        }
;;;295      }
;;;296    
;;;297      /* At this step, return the status of initialization */
;;;298      return InitStatus;
;;;299    }
00011a  bd30              POP      {r4,r5,pc}
;;;300    
                          ENDP


                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=1

                  CAN_MessagePending PROC
;;;652      */
;;;653    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  4602              MOV      r2,r0
;;;654    {
;;;655      uint8_t message_pending=0;
000002  2000              MOVS     r0,#0
;;;656      /* Check the parameters */
;;;657      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;658      assert_param(IS_CAN_FIFO(FIFONumber));
;;;659      if (FIFONumber == CAN_FIFO0)
000004  b919              CBNZ     r1,|L12.14|
;;;660      {
;;;661        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
000006  68d3              LDR      r3,[r2,#0xc]
000008  f0030003          AND      r0,r3,#3
00000c  e006              B        |L12.28|
                  |L12.14|
;;;662      }
;;;663      else if (FIFONumber == CAN_FIFO1)
00000e  2901              CMP      r1,#1
000010  d103              BNE      |L12.26|
;;;664      {
;;;665        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
000012  6913              LDR      r3,[r2,#0x10]
000014  f0030003          AND      r0,r3,#3
000018  e000              B        |L12.28|
                  |L12.26|
;;;666      }
;;;667      else
;;;668      {
;;;669        message_pending = 0;
00001a  2000              MOVS     r0,#0
                  |L12.28|
;;;670      }
;;;671      return message_pending;
;;;672    }
00001c  4770              BX       lr
;;;673    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;681      */
;;;682    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;683    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4613              MOV      r3,r2
;;;684      /* Check the parameters */
;;;685      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;686      assert_param(IS_CAN_FIFO(FIFONumber));
;;;687      /* Get the Id */
;;;688      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000008  f50470d8          ADD      r0,r4,#0x1b0
00000c  eb001005          ADD      r0,r0,r5,LSL #4
000010  6800              LDR      r0,[r0,#0]
000012  f0000004          AND      r0,r0,#4
000016  7218              STRB     r0,[r3,#8]
;;;689      if (RxMessage->IDE == CAN_ID_STD)
000018  7a18              LDRB     r0,[r3,#8]
00001a  b950              CBNZ     r0,|L13.50|
;;;690      {
;;;691        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
00001c  f50470d8          ADD      r0,r4,#0x1b0
000020  eb001005          ADD      r0,r0,r5,LSL #4
000024  6800              LDR      r0,[r0,#0]
000026  f24071ff          MOV      r1,#0x7ff
00002a  ea015050          AND      r0,r1,r0,LSR #21
00002e  6018              STR      r0,[r3,#0]
000030  e009              B        |L13.70|
                  |L13.50|
;;;692      }
;;;693      else
;;;694      {
;;;695        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000032  f50470d8          ADD      r0,r4,#0x1b0
000036  eb001005          ADD      r0,r0,r5,LSL #4
00003a  6800              LDR      r0,[r0,#0]
00003c  f06f4160          MVN      r1,#0xe0000000
000040  ea0100d0          AND      r0,r1,r0,LSR #3
000044  6058              STR      r0,[r3,#4]
                  |L13.70|
;;;696      }
;;;697      
;;;698      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
000046  f50470d8          ADD      r0,r4,#0x1b0
00004a  eb001005          ADD      r0,r0,r5,LSL #4
00004e  6800              LDR      r0,[r0,#0]
000050  f0000002          AND      r0,r0,#2
000054  7258              STRB     r0,[r3,#9]
;;;699      /* Get the DLC */
;;;700      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000056  f50470d8          ADD      r0,r4,#0x1b0
00005a  eb001005          ADD      r0,r0,r5,LSL #4
00005e  6840              LDR      r0,[r0,#4]
000060  f000000f          AND      r0,r0,#0xf
000064  7298              STRB     r0,[r3,#0xa]
;;;701      /* Get the FMI */
;;;702      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
000066  f50470d8          ADD      r0,r4,#0x1b0
00006a  eb001005          ADD      r0,r0,r5,LSL #4
00006e  6840              LDR      r0,[r0,#4]
000070  0a00              LSRS     r0,r0,#8
000072  74d8              STRB     r0,[r3,#0x13]
;;;703      /* Get the data field */
;;;704      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
000074  f50470d8          ADD      r0,r4,#0x1b0
000078  eb001005          ADD      r0,r0,r5,LSL #4
00007c  6880              LDR      r0,[r0,#8]
00007e  72d8              STRB     r0,[r3,#0xb]
;;;705      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
000080  f50470d8          ADD      r0,r4,#0x1b0
000084  eb001005          ADD      r0,r0,r5,LSL #4
000088  6880              LDR      r0,[r0,#8]
00008a  0a00              LSRS     r0,r0,#8
00008c  7318              STRB     r0,[r3,#0xc]
;;;706      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
00008e  f50470d8          ADD      r0,r4,#0x1b0
000092  eb001005          ADD      r0,r0,r5,LSL #4
000096  6880              LDR      r0,[r0,#8]
000098  0c00              LSRS     r0,r0,#16
00009a  7358              STRB     r0,[r3,#0xd]
;;;707      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
00009c  f50470d8          ADD      r0,r4,#0x1b0
0000a0  eb001005          ADD      r0,r0,r5,LSL #4
0000a4  6880              LDR      r0,[r0,#8]
0000a6  0e00              LSRS     r0,r0,#24
0000a8  7398              STRB     r0,[r3,#0xe]
;;;708      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
0000aa  f50470d8          ADD      r0,r4,#0x1b0
0000ae  eb001005          ADD      r0,r0,r5,LSL #4
0000b2  68c0              LDR      r0,[r0,#0xc]
0000b4  73d8              STRB     r0,[r3,#0xf]
;;;709      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
0000b6  f50470d8          ADD      r0,r4,#0x1b0
0000ba  eb001005          ADD      r0,r0,r5,LSL #4
0000be  68c0              LDR      r0,[r0,#0xc]
0000c0  0a00              LSRS     r0,r0,#8
0000c2  7418              STRB     r0,[r3,#0x10]
;;;710      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
0000c4  f50470d8          ADD      r0,r4,#0x1b0
0000c8  eb001005          ADD      r0,r0,r5,LSL #4
0000cc  68c0              LDR      r0,[r0,#0xc]
0000ce  0c00              LSRS     r0,r0,#16
0000d0  7458              STRB     r0,[r3,#0x11]
;;;711      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
0000d2  f50470d8          ADD      r0,r4,#0x1b0
0000d6  eb001005          ADD      r0,r0,r5,LSL #4
0000da  68c0              LDR      r0,[r0,#0xc]
0000dc  0e00              LSRS     r0,r0,#24
0000de  7498              STRB     r0,[r3,#0x12]
;;;712      /* Release the FIFO */
;;;713      CAN_FIFORelease(CANx, FIFONumber);
0000e0  4629              MOV      r1,r5
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       CAN_FIFORelease
;;;714    }
0000e8  bd30              POP      {r4,r5,pc}
;;;715    
                          ENDP


                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;432      */
;;;433    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  490f              LDR      r1,|L14.64|
;;;434    {
;;;435      /* Check the parameters */
;;;436      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;437      /* enter Initialisation mode for the filter */
;;;438      CAN1->FMR |= FMR_FINIT;
000002  6809              LDR      r1,[r1,#0]
000004  f0410101          ORR      r1,r1,#1
000008  4a0e              LDR      r2,|L14.68|
00000a  f8c21600          STR      r1,[r2,#0x600]
;;;439      /* Select the start slave bank */
;;;440      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
00000e  490c              LDR      r1,|L14.64|
000010  6809              LDR      r1,[r1,#0]
000012  f643720e          MOV      r2,#0x3f0e
000016  ea210102          BIC      r1,r1,r2
00001a  4a0a              LDR      r2,|L14.68|
00001c  f8c21600          STR      r1,[r2,#0x600]
;;;441      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000020  4611              MOV      r1,r2
000022  f8d11600          LDR      r1,[r1,#0x600]
000026  ea412100          ORR      r1,r1,r0,LSL #8
00002a  f8c21600          STR      r1,[r2,#0x600]
;;;442      /* Leave Initialisation mode for the filter */
;;;443      CAN1->FMR &= ~FMR_FINIT;
00002e  4611              MOV      r1,r2
000030  f8d11600          LDR      r1,[r1,#0x600]
000034  f0210101          BIC      r1,r1,#1
000038  f8c21600          STR      r1,[r2,#0x600]
;;;444    }
00003c  4770              BX       lr
;;;445    
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      0x40006600
                  |L14.68|
                          DCD      0x40006000

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=1

                  CAN_Sleep PROC
;;;745      */
;;;746    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;747    {
;;;748      uint8_t sleepstatus = CANSLEEPFAILED;
000002  2000              MOVS     r0,#0
;;;749      
;;;750      /* Check the parameters */
;;;751      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;752        
;;;753      /* Request Sleep mode */
;;;754       CANx->MCR = (((CANx->MCR) & (uint32_t)(~MCR_INRQ)) | MCR_SLEEP);
000004  680a              LDR      r2,[r1,#0]
000006  f0220201          BIC      r2,r2,#1
00000a  f0420202          ORR      r2,r2,#2
00000e  600a              STR      r2,[r1,#0]
;;;755       
;;;756      /* Sleep mode status */
;;;757      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
000010  684a              LDR      r2,[r1,#4]
000012  f0020203          AND      r2,r2,#3
000016  2a02              CMP      r2,#2
000018  d100              BNE      |L15.28|
;;;758      {
;;;759        /* Sleep mode not entered */
;;;760        sleepstatus =  CANSLEEPOK;
00001a  2001              MOVS     r0,#1
                  |L15.28|
;;;761      }
;;;762      /* At this step, sleep mode status */
;;;763       return (uint8_t)sleepstatus;
;;;764    }
00001c  4770              BX       lr
;;;765    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;399      */
;;;400    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;401    {
;;;402      /* Reset CAN init structure parameters values */
;;;403      /* Initialize the time triggered communication mode */
;;;404      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;405      /* Initialize the automatic bus-off management */
;;;406      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;407      /* Initialize the automatic wake-up mode */
;;;408      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;409      /* Initialize the no automatic retransmission */
;;;410      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;411      /* Initialize the receive FIFO locked mode */
;;;412      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;413      /* Initialize the transmit FIFO priority */
;;;414      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;415      /* Initialize the CAN_Mode member */
;;;416      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;417      /* Initialize the CAN_SJW member */
;;;418      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;419      /* Initialize the CAN_BS1 member */
;;;420      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;421      /* Initialize the CAN_BS2 member */
;;;422      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;423      /* Initialize the CAN_Prescaler member */
;;;424      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;425    }
00001e  4770              BX       lr
;;;426    
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;485      */
;;;486    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b510              PUSH     {r4,lr}
;;;487    {
000002  4602              MOV      r2,r0
;;;488      uint8_t transmit_mailbox = 0;
000004  2000              MOVS     r0,#0
;;;489      /* Check the parameters */
;;;490      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;491      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;492      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;493      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;494    
;;;495      /* Select one empty transmit mailbox */
;;;496      if ((CANx->TSR&TSR_TME0) == TSR_TME0)
000006  6893              LDR      r3,[r2,#8]
000008  f0036380          AND      r3,r3,#0x4000000
00000c  f1b36f80          CMP      r3,#0x4000000
000010  d100              BNE      |L17.20|
;;;497      {
;;;498        transmit_mailbox = 0;
000012  e010              B        |L17.54|
                  |L17.20|
;;;499      }
;;;500      else if ((CANx->TSR&TSR_TME1) == TSR_TME1)
000014  6893              LDR      r3,[r2,#8]
000016  f0036300          AND      r3,r3,#0x8000000
00001a  f1b36f00          CMP      r3,#0x8000000
00001e  d101              BNE      |L17.36|
;;;501      {
;;;502        transmit_mailbox = 1;
000020  2001              MOVS     r0,#1
000022  e008              B        |L17.54|
                  |L17.36|
;;;503      }
;;;504      else if ((CANx->TSR&TSR_TME2) == TSR_TME2)
000024  6893              LDR      r3,[r2,#8]
000026  f0035380          AND      r3,r3,#0x10000000
00002a  f1b35f80          CMP      r3,#0x10000000
00002e  d101              BNE      |L17.52|
;;;505      {
;;;506        transmit_mailbox = 2;
000030  2002              MOVS     r0,#2
000032  e000              B        |L17.54|
                  |L17.52|
;;;507      }
;;;508      else
;;;509      {
;;;510        transmit_mailbox = CAN_NO_MB;
000034  2004              MOVS     r0,#4
                  |L17.54|
;;;511      }
;;;512    
;;;513      if (transmit_mailbox != CAN_NO_MB)
000036  2804              CMP      r0,#4
000038  d074              BEQ      |L17.292|
;;;514      {
;;;515        /* Set up the Id */
;;;516        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00003a  f50273c0          ADD      r3,r2,#0x180
00003e  eb031300          ADD      r3,r3,r0,LSL #4
000042  681b              LDR      r3,[r3,#0]
000044  f0030401          AND      r4,r3,#1
000048  f50273c0          ADD      r3,r2,#0x180
00004c  eb031300          ADD      r3,r3,r0,LSL #4
000050  601c              STR      r4,[r3,#0]
;;;517        if (TxMessage->IDE == CAN_ID_STD)
000052  7a0b              LDRB     r3,[r1,#8]
000054  b97b              CBNZ     r3,|L17.118|
;;;518        {
;;;519          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;520          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | TxMessage->RTR);
000056  7a4b              LDRB     r3,[r1,#9]
000058  680c              LDR      r4,[r1,#0]
00005a  ea435344          ORR      r3,r3,r4,LSL #21
00005e  f50274c0          ADD      r4,r2,#0x180
000062  eb041400          ADD      r4,r4,r0,LSL #4
000066  6824              LDR      r4,[r4,#0]
000068  4323              ORRS     r3,r3,r4
00006a  f50274c0          ADD      r4,r2,#0x180
00006e  eb041400          ADD      r4,r4,r0,LSL #4
000072  6023              STR      r3,[r4,#0]
000074  e010              B        |L17.152|
                  |L17.118|
;;;521        }
;;;522        else
;;;523        {
;;;524          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;525          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId<<3) | TxMessage->IDE | 
000076  7a0b              LDRB     r3,[r1,#8]
000078  684c              LDR      r4,[r1,#4]
00007a  ea4303c4          ORR      r3,r3,r4,LSL #3
00007e  7a4c              LDRB     r4,[r1,#9]
000080  4323              ORRS     r3,r3,r4
000082  f50274c0          ADD      r4,r2,#0x180
000086  eb041400          ADD      r4,r4,r0,LSL #4
00008a  6824              LDR      r4,[r4,#0]
00008c  4323              ORRS     r3,r3,r4
00008e  f50274c0          ADD      r4,r2,#0x180
000092  eb041400          ADD      r4,r4,r0,LSL #4
000096  6023              STR      r3,[r4,#0]
                  |L17.152|
;;;526                                                   TxMessage->RTR);
;;;527        }
;;;528        
;;;529    
;;;530        /* Set up the DLC */
;;;531        TxMessage->DLC &= (uint8_t)0x0000000F;
000098  7a8b              LDRB     r3,[r1,#0xa]
00009a  f003030f          AND      r3,r3,#0xf
00009e  728b              STRB     r3,[r1,#0xa]
;;;532        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
0000a0  f50273c0          ADD      r3,r2,#0x180
0000a4  eb031300          ADD      r3,r3,r0,LSL #4
0000a8  685b              LDR      r3,[r3,#4]
0000aa  f023040f          BIC      r4,r3,#0xf
0000ae  f50273c0          ADD      r3,r2,#0x180
0000b2  eb031300          ADD      r3,r3,r0,LSL #4
0000b6  605c              STR      r4,[r3,#4]
;;;533        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
0000b8  f50273c0          ADD      r3,r2,#0x180
0000bc  eb031300          ADD      r3,r3,r0,LSL #4
0000c0  685b              LDR      r3,[r3,#4]
0000c2  7a8c              LDRB     r4,[r1,#0xa]
0000c4  4323              ORRS     r3,r3,r4
0000c6  f50274c0          ADD      r4,r2,#0x180
0000ca  eb041400          ADD      r4,r4,r0,LSL #4
0000ce  6063              STR      r3,[r4,#4]
;;;534    
;;;535        /* Set up the data field */
;;;536        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
0000d0  7b8b              LDRB     r3,[r1,#0xe]
0000d2  061c              LSLS     r4,r3,#24
0000d4  7b4b              LDRB     r3,[r1,#0xd]
0000d6  ea444403          ORR      r4,r4,r3,LSL #16
0000da  7b0b              LDRB     r3,[r1,#0xc]
0000dc  ea442303          ORR      r3,r4,r3,LSL #8
0000e0  7acc              LDRB     r4,[r1,#0xb]
0000e2  4323              ORRS     r3,r3,r4
0000e4  f50274c0          ADD      r4,r2,#0x180
0000e8  eb041400          ADD      r4,r4,r0,LSL #4
0000ec  60a3              STR      r3,[r4,#8]
;;;537                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;538                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;539                                                 ((uint32_t)TxMessage->Data[0]));
;;;540        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
0000ee  7c8b              LDRB     r3,[r1,#0x12]
0000f0  061c              LSLS     r4,r3,#24
0000f2  7c4b              LDRB     r3,[r1,#0x11]
0000f4  ea444403          ORR      r4,r4,r3,LSL #16
0000f8  7c0b              LDRB     r3,[r1,#0x10]
0000fa  ea442303          ORR      r3,r4,r3,LSL #8
0000fe  7bcc              LDRB     r4,[r1,#0xf]
000100  4323              ORRS     r3,r3,r4
000102  f50274c0          ADD      r4,r2,#0x180
000106  eb041400          ADD      r4,r4,r0,LSL #4
00010a  60e3              STR      r3,[r4,#0xc]
;;;541                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;542                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;543                                                 ((uint32_t)TxMessage->Data[4]));
;;;544        /* Request transmission */
;;;545        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00010c  f50273c0          ADD      r3,r2,#0x180
000110  eb031300          ADD      r3,r3,r0,LSL #4
000114  681b              LDR      r3,[r3,#0]
000116  f0430401          ORR      r4,r3,#1
00011a  f50273c0          ADD      r3,r2,#0x180
00011e  eb031300          ADD      r3,r3,r0,LSL #4
000122  601c              STR      r4,[r3,#0]
                  |L17.292|
;;;546      }
;;;547      return transmit_mailbox;
;;;548    }
000124  bd10              POP      {r4,pc}
;;;549    
                          ENDP


                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=1

                  CAN_TransmitStatus PROC
;;;555      */
;;;556    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  4602              MOV      r2,r0
;;;557    {
;;;558      /* RQCP, TXOK and TME bits */
;;;559      uint8_t state = 0;
000002  2000              MOVS     r0,#0
;;;560      /* Check the parameters */
;;;561      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;562      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;563      switch (TransmitMailbox)
000004  b121              CBZ      r1,|L18.16|
000006  2901              CMP      r1,#1
000008  d00f              BEQ      |L18.42|
00000a  2902              CMP      r1,#2
00000c  d12b              BNE      |L18.102|
00000e  e01b              B        |L18.72|
                  |L18.16|
;;;564      {
;;;565        case (0): state |= (uint8_t)((CANx->TSR & TSR_RQCP0) << 2);
000010  6893              LDR      r3,[r2,#8]
000012  07db              LSLS     r3,r3,#31
000014  ea407053          ORR      r0,r0,r3,LSR #29
;;;566          state |= (uint8_t)((CANx->TSR & TSR_TXOK0) >> 0);
000018  6893              LDR      r3,[r2,#8]
00001a  f0030302          AND      r3,r3,#2
00001e  4318              ORRS     r0,r0,r3
;;;567          state |= (uint8_t)((CANx->TSR & TSR_TME0) >> 26);
000020  6893              LDR      r3,[r2,#8]
000022  f3c36380          UBFX     r3,r3,#26,#1
000026  4318              ORRS     r0,r0,r3
;;;568          break;
000028  e01f              B        |L18.106|
                  |L18.42|
;;;569        case (1): state |= (uint8_t)((CANx->TSR & TSR_RQCP1) >> 6);
00002a  6893              LDR      r3,[r2,#8]
00002c  f4037380          AND      r3,r3,#0x100
000030  ea401093          ORR      r0,r0,r3,LSR #6
;;;570          state |= (uint8_t)((CANx->TSR & TSR_TXOK1) >> 8);
000034  6893              LDR      r3,[r2,#8]
000036  f4037300          AND      r3,r3,#0x200
00003a  ea402013          ORR      r0,r0,r3,LSR #8
;;;571          state |= (uint8_t)((CANx->TSR & TSR_TME1) >> 27);
00003e  6893              LDR      r3,[r2,#8]
000040  f3c363c0          UBFX     r3,r3,#27,#1
000044  4318              ORRS     r0,r0,r3
;;;572          break;
000046  e010              B        |L18.106|
                  |L18.72|
;;;573        case (2): state |= (uint8_t)((CANx->TSR & TSR_RQCP2) >> 14);
000048  6893              LDR      r3,[r2,#8]
00004a  f4033380          AND      r3,r3,#0x10000
00004e  ea403093          ORR      r0,r0,r3,LSR #14
;;;574          state |= (uint8_t)((CANx->TSR & TSR_TXOK2) >> 16);
000052  6893              LDR      r3,[r2,#8]
000054  f4033300          AND      r3,r3,#0x20000
000058  ea404013          ORR      r0,r0,r3,LSR #16
;;;575          state |= (uint8_t)((CANx->TSR & TSR_TME2) >> 28);
00005c  6893              LDR      r3,[r2,#8]
00005e  f3c37300          UBFX     r3,r3,#28,#1
000062  4318              ORRS     r0,r0,r3
;;;576          break;
000064  e001              B        |L18.106|
                  |L18.102|
;;;577        default:
;;;578          state = CANTXFAILED;
000066  2000              MOVS     r0,#0
;;;579          break;
000068  bf00              NOP      
                  |L18.106|
00006a  bf00              NOP                            ;568
;;;580      }
;;;581      switch (state)
00006c  b120              CBZ      r0,|L18.120|
00006e  2805              CMP      r0,#5
000070  d004              BEQ      |L18.124|
000072  2807              CMP      r0,#7
000074  d106              BNE      |L18.132|
000076  e003              B        |L18.128|
                  |L18.120|
;;;582      {
;;;583          /* transmit pending  */
;;;584        case (0x0): state = CANTXPENDING;
000078  2002              MOVS     r0,#2
;;;585          break;
00007a  e005              B        |L18.136|
                  |L18.124|
;;;586          /* transmit failed  */
;;;587        case (0x5): state = CANTXFAILED;
00007c  2000              MOVS     r0,#0
;;;588          break;
00007e  e003              B        |L18.136|
                  |L18.128|
;;;589          /* transmit succedeed  */
;;;590        case (0x7): state = CANTXOK;
000080  2001              MOVS     r0,#1
;;;591          break;
000082  e001              B        |L18.136|
                  |L18.132|
;;;592        default:
;;;593          state = CANTXFAILED;
000084  2000              MOVS     r0,#0
;;;594          break;
000086  bf00              NOP      
                  |L18.136|
000088  bf00              NOP                            ;585
;;;595      }
;;;596      return state;
;;;597    }
00008a  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=1

                  CAN_WakeUp PROC
;;;770      */
;;;771    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;772    {
;;;773      uint32_t wait_slak = SLAK_TimeOut	;
000002  f64f72ff          MOV      r2,#0xffff
;;;774      uint8_t wakeupstatus = CANWAKEUPFAILED;
000006  2000              MOVS     r0,#0
;;;775      
;;;776      /* Check the parameters */
;;;777      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;778        
;;;779      /* Wake up request */
;;;780      CANx->MCR &= ~MCR_SLEEP;
000008  680b              LDR      r3,[r1,#0]
00000a  f0230302          BIC      r3,r3,#2
00000e  600b              STR      r3,[r1,#0]
;;;781        
;;;782      /* Sleep mode status */
;;;783      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000010  e000              B        |L19.20|
                  |L19.18|
;;;784      {
;;;785       wait_slak--;
000012  1e52              SUBS     r2,r2,#1
                  |L19.20|
000014  684b              LDR      r3,[r1,#4]            ;783
000016  f0030302          AND      r3,r3,#2              ;783
00001a  2b02              CMP      r3,#2                 ;783
00001c  d101              BNE      |L19.34|
00001e  2a00              CMP      r2,#0                 ;783
000020  d1f7              BNE      |L19.18|
                  |L19.34|
;;;786      }
;;;787      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
000022  684b              LDR      r3,[r1,#4]
000024  f0030302          AND      r3,r3,#2
000028  2b02              CMP      r3,#2
00002a  d000              BEQ      |L19.46|
;;;788      {
;;;789       /* Sleep mode exited */
;;;790        wakeupstatus = CANWAKEUPOK;
00002c  2001              MOVS     r0,#1
                  |L19.46|
;;;791      }
;;;792      /* At this step, sleep mode status */
;;;793      return (uint8_t)wakeupstatus;
;;;794    }
00002e  4770              BX       lr
;;;795    
                          ENDP


                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;960      */
;;;961    static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;962    {
;;;963      ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;964      
;;;965      if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  420a              TST      r2,r1
000006  d001              BEQ      |L20.12|
;;;966      {
;;;967        /* CAN_IT is set */
;;;968        pendingbitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L20.14|
                  |L20.12|
;;;969      }
;;;970      else
;;;971      {
;;;972        /* CAN_IT is reset */
;;;973        pendingbitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L20.14|
;;;974      }
;;;975      return pendingbitstatus;
;;;976    }
00000e  4770              BX       lr
;;;977    
                          ENDP

