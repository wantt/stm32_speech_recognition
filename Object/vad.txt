; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Object\vad.o --depend=.\Object\vad.d --feedback=.\Object\stm32-speech-recognition.fed --cpu=Cortex-M3 --apcs=interwork -O0 -Otime -I.\Src\APP -I.\Src\BSP -I.\Src\GUI -I.\Src\CM3_SYS -I.\Src\FATFS -I.\Src\StdPeriph_Driver -I.\Src\StdPeriph_Driver\inc -I.\Src\Speech_Recog -IE:\SoftWare\KEIL\Keil4\path\ARM\INC -IE:\SoftWare\KEIL\Keil4\path\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\Object\vad.crf Src\Speech_Recog\VAD.C]
                          THUMB

                          AREA ||i.VAD||, CODE, READONLY, ALIGN=1

                  VAD PROC
;;;96     *********/
;;;97     void VAD(const u16 *vc, u16 buf_len, valid_tag *valid_voice, atap_tag *atap_arg)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;98     {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
;;;99     	u8	last_sig=0;	// 上次跃出门限带的状态 1:门限带以下；2:门限带以上
00000a  f04f0c00          MOV      r12,#0
;;;100    	u8	cur_stus=0;	// 当前语音段状态 0无声段  1前端过渡段  2语音段  3后端过渡段
00000e  2200              MOVS     r2,#0
;;;101    	u16 front_duration=0;//前端过渡段超过门限值持续帧数
000010  4690              MOV      r8,r2
;;;102    	u16 back_duration=0;//后端过渡段低于门限值持续帧数
000012  4691              MOV      r9,r2
;;;103    	u32 h,i;
;;;104    	u32 frm_sum;	// 短时绝对值和
;;;105    	u32 frm_zero;	// 短时过零(门限)率
;;;106    	u32 a_thl;	// 上门限值
;;;107    	u32 b_thl;	// 下门限值
;;;108    	
;;;109    	u8 	valid_con=0;//语音段计数 最大max_vc_con
000014  2600              MOVS     r6,#0
;;;110    	u32 frm_con=0;	//帧计数
000016  4693              MOV      r11,r2
000018  f8cdb000          STR      r11,[sp,#0]
;;;111    	
;;;112    	a_thl=atap_arg->mid_val+atap_arg->n_thl;
00001c  f8b3e004          LDRH     lr,[r3,#4]
000020  f8d3b000          LDR      r11,[r3,#0]
000024  44f3              ADD      r11,r11,lr
000026  f8cdb008          STR      r11,[sp,#8]
;;;113    	b_thl=atap_arg->mid_val-atap_arg->n_thl;
00002a  f8b3e004          LDRH     lr,[r3,#4]
00002e  f8d3b000          LDR      r11,[r3,#0]
000032  ebab0b0e          SUB      r11,r11,lr
000036  f8cdb004          STR      r11,[sp,#4]
;;;114    	
;;;115    	for(i=0;i<max_vc_con;i++)
00003a  2000              MOVS     r0,#0
00003c  e008              B        |L1.80|
                  |L1.62|
;;;116    	{
;;;117    		((valid_tag*)(valid_voice+i))->start=(void *)0;
00003e  f04f0b00          MOV      r11,#0
000042  f845b030          STR      r11,[r5,r0,LSL #3]
;;;118    		((valid_tag*)(valid_voice+i))->end=(void *)0;
000046  eb050ec0          ADD      lr,r5,r0,LSL #3
00004a  f8ceb004          STR      r11,[lr,#4]
00004e  1c40              ADDS     r0,r0,#1              ;115
                  |L1.80|
000050  2803              CMP      r0,#3                 ;115
000052  d3f4              BCC      |L1.62|
;;;119    	}
;;;120    	
;;;121    	for(i=0;i<(buf_len-frame_len);i+=(frame_len-frame_mov))
000054  2000              MOVS     r0,#0
000056  e0ad              B        |L1.436|
                  |L1.88|
;;;122    	{
;;;123    		frm_con++;
000058  f8ddb000          LDR      r11,[sp,#0]
00005c  f10b0b01          ADD      r11,r11,#1
000060  f8cdb000          STR      r11,[sp,#0]
;;;124    
;;;125    		frm_sum=0;
000064  f04f0a00          MOV      r10,#0
;;;126    		for(h=0;h<frame_len;h++)//短时绝对值和
000068  2100              MOVS     r1,#0
00006a  e01a              B        |L1.162|
                  |L1.108|
;;;127    		{
;;;128    			frm_sum+=(*(vc+i+h)>(atap_arg->mid_val))?(*(vc+i+h)-(atap_arg->mid_val)):((atap_arg->mid_val)-*(vc+i+h));
00006c  eb040b40          ADD      r11,r4,r0,LSL #1
000070  f83bb011          LDRH     r11,[r11,r1,LSL #1]
000074  f8d3e000          LDR      lr,[r3,#0]
000078  45f3              CMP      r11,lr
00007a  d908              BLS      |L1.142|
00007c  eb040b40          ADD      r11,r4,r0,LSL #1
000080  f83bb011          LDRH     r11,[r11,r1,LSL #1]
000084  f8d3e000          LDR      lr,[r3,#0]
000088  ebab0b0e          SUB      r11,r11,lr
00008c  e007              B        |L1.158|
                  |L1.142|
00008e  eb040b40          ADD      r11,r4,r0,LSL #1
000092  f83bb011          LDRH     r11,[r11,r1,LSL #1]
000096  f8d3e000          LDR      lr,[r3,#0]
00009a  ebae0b0b          SUB      r11,lr,r11
                  |L1.158|
00009e  44da              ADD      r10,r10,r11
0000a0  1c49              ADDS     r1,r1,#1              ;126
                  |L1.162|
0000a2  29a0              CMP      r1,#0xa0              ;126
0000a4  d3e2              BCC      |L1.108|
;;;129    		}
;;;130    		
;;;131    		frm_zero=0;
0000a6  2700              MOVS     r7,#0
;;;132    		for(h=0;h<(frame_len-1);h++)//短时过门限率
0000a8  2100              MOVS     r1,#0
0000aa  e032              B        |L1.274|
                  |L1.172|
;;;133    		{
;;;134    			if(*(vc+i+h)>=a_thl)			//大于上门限值
0000ac  eb040b40          ADD      r11,r4,r0,LSL #1
0000b0  f83be011          LDRH     lr,[r11,r1,LSL #1]
0000b4  f8ddb008          LDR      r11,[sp,#8]
0000b8  45de              CMP      lr,r11
0000ba  d302              BCC      |L1.194|
;;;135    			{
;;;136    				last_sig=2;
0000bc  f04f0c02          MOV      r12,#2
0000c0  e009              B        |L1.214|
                  |L1.194|
;;;137    			}
;;;138    			else if(*(vc+i+h)<b_thl)	//小于下门限值
0000c2  eb040b40          ADD      r11,r4,r0,LSL #1
0000c6  f83be011          LDRH     lr,[r11,r1,LSL #1]
0000ca  f8ddb004          LDR      r11,[sp,#4]
0000ce  45de              CMP      lr,r11
0000d0  d201              BCS      |L1.214|
;;;139    			{
;;;140    				last_sig=1;
0000d2  f04f0c01          MOV      r12,#1
                  |L1.214|
;;;141    			}
;;;142    			
;;;143    			if(*(vc+i+h+1)>=a_thl)
0000d6  eb040b40          ADD      r11,r4,r0,LSL #1
0000da  eb0b0b41          ADD      r11,r11,r1,LSL #1
0000de  f8bbe002          LDRH     lr,[r11,#2]
0000e2  f8ddb008          LDR      r11,[sp,#8]
0000e6  45de              CMP      lr,r11
0000e8  d304              BCC      |L1.244|
;;;144    			{
;;;145    				if(last_sig==1)
0000ea  f1bc0f01          CMP      r12,#1
0000ee  d10f              BNE      |L1.272|
;;;146    				{
;;;147    					frm_zero++;
0000f0  1c7f              ADDS     r7,r7,#1
0000f2  e00d              B        |L1.272|
                  |L1.244|
;;;148    				}
;;;149    			}
;;;150    			else if(*(vc+i+h+1)<b_thl)
0000f4  eb040b40          ADD      r11,r4,r0,LSL #1
0000f8  eb0b0b41          ADD      r11,r11,r1,LSL #1
0000fc  f8bbe002          LDRH     lr,[r11,#2]
000100  f8ddb004          LDR      r11,[sp,#4]
000104  45de              CMP      lr,r11
000106  d203              BCS      |L1.272|
;;;151    			{
;;;152    				if(last_sig==2)
000108  f1bc0f02          CMP      r12,#2
00010c  d100              BNE      |L1.272|
;;;153    				{
;;;154    					frm_zero++;
00010e  1c7f              ADDS     r7,r7,#1
                  |L1.272|
000110  1c49              ADDS     r1,r1,#1              ;132
                  |L1.274|
000112  299f              CMP      r1,#0x9f              ;132
000114  d3ca              BCC      |L1.172|
;;;155    				}
;;;156    			}
;;;157    		}
;;;158    		/*	 	
;;;159    		USART1_printf("frm_con=%d ",frm_con);
;;;160    		USART1_printf("frm_sum=%d ",frm_sum);
;;;161    		USART1_printf("frm_zero=%d\r\n",frm_zero); 
;;;162    		*/ 
;;;163    		
;;;164    		if((frm_sum>(atap_arg->s_thl))||(frm_zero>(atap_arg->z_thl)))
000116  f8d3b008          LDR      r11,[r3,#8]
00011a  45d3              CMP      r11,r10
00011c  d303              BCC      |L1.294|
00011e  f8b3b006          LDRH     r11,[r3,#6]
000122  45bb              CMP      r11,r7
000124  d21c              BCS      |L1.352|
                  |L1.294|
;;;165    		//至少有一个参数超过其门限值
;;;166    		{
;;;167    			if(cur_stus==0) //如果当前是无声段
000126  b912              CBNZ     r2,|L1.302|
;;;168    			{
;;;169    				cur_stus=1; //进入前端过渡段 
000128  2201              MOVS     r2,#1
;;;170    				front_duration=1; //前端过渡段持续帧数置1 第一帧
00012a  4690              MOV      r8,r2
00012c  e041              B        |L1.434|
                  |L1.302|
;;;171    			}
;;;172    			else if(cur_stus==1) //当前是前端过渡段
00012e  2a01              CMP      r2,#1
000130  d110              BNE      |L1.340|
;;;173    			{
;;;174    				front_duration++;
000132  f1080b01          ADD      r11,r8,#1
000136  fa1ff88b          UXTH     r8,r11
;;;175    				if(front_duration>=v_durmin_f) //前端过渡段帧数超过最短有效语音帧数
00013a  f1b80f08          CMP      r8,#8
00013e  db38              BLT      |L1.434|
;;;176    				{
;;;177    					cur_stus=2; //进入语音段
000140  2202              MOVS     r2,#2
;;;178    					((valid_tag*)(valid_voice+valid_con))->start=(u16*)vc+i-((v_durmin_f-1)*(frame_len-frame_mov));//记录起始帧位置
000142  eb040b40          ADD      r11,r4,r0,LSL #1
000146  f5ab6b8c          SUB      r11,r11,#0x460
00014a  f845b036          STR      r11,[r5,r6,LSL #3]
;;;179    					front_duration=0; //前端过渡段持续帧数置0
00014e  f04f0800          MOV      r8,#0
000152  e02e              B        |L1.434|
                  |L1.340|
;;;180    				}
;;;181    			}
;;;182    			else if(cur_stus==3) //如果当前是后端过渡段 两参数都回升到门限值以上
000154  2a03              CMP      r2,#3
000156  d12c              BNE      |L1.434|
;;;183    			{
;;;184    				back_duration=0;
000158  f04f0900          MOV      r9,#0
;;;185    				cur_stus=2; //记为语音段
00015c  2202              MOVS     r2,#2
00015e  e028              B        |L1.434|
                  |L1.352|
;;;186    			}
;;;187    		}
;;;188    		else //两参数都在门限值以下
;;;189    		{
;;;190    			if(cur_stus==2) //当前是语音段
000160  2a02              CMP      r2,#2
000162  d103              BNE      |L1.364|
;;;191    			{
;;;192    				cur_stus=3;//设为后端过渡段
000164  2203              MOVS     r2,#3
;;;193    				back_duration=1; //前端过渡段持续帧数置1 第一帧
000166  f04f0901          MOV      r9,#1
00016a  e022              B        |L1.434|
                  |L1.364|
;;;194    			}
;;;195    			else if(cur_stus==3)//当前是后端过渡段
00016c  2a03              CMP      r2,#3
00016e  d11b              BNE      |L1.424|
;;;196    			{
;;;197    				back_duration++;
000170  f1090b01          ADD      r11,r9,#1
000174  fa1ff98b          UXTH     r9,r11
;;;198    				if(back_duration>=s_durmax_f) //后端过渡段帧数超过最长无声帧数
000178  f1b90f0b          CMP      r9,#0xb
00017c  db19              BLT      |L1.434|
;;;199    				{
;;;200    					cur_stus=0; //进入无声段
00017e  2200              MOVS     r2,#0
;;;201    					((valid_tag*)(valid_voice+valid_con))->end=(u16*)vc+i-(s_durmax_f*(frame_len-frame_mov))+frame_len;//记录结束帧位置
000180  eb040b40          ADD      r11,r4,r0,LSL #1
000184  f5ab6bb4          SUB      r11,r11,#0x5a0
000188  eb050ec6          ADD      lr,r5,r6,LSL #3
00018c  f8ceb004          STR      r11,[lr,#4]
;;;202    					valid_con++;
000190  f1060b01          ADD      r11,r6,#1
000194  f00b06ff          AND      r6,r11,#0xff
;;;203    					if(valid_con==max_vc_con)
000198  2e03              CMP      r6,#3
00019a  d102              BNE      |L1.418|
                  |L1.412|
;;;204    					{
;;;205    						return;
;;;206    					}
;;;207    					back_duration=0;
;;;208    				}
;;;209    			}
;;;210    			else if(cur_stus==1)//当前是前端过渡段 两参数都回落到门限值以下   
;;;211    								//持续时间低于语音最短时间门限 视为短时噪声
;;;212    			{
;;;213    				front_duration=0;
;;;214    				cur_stus=0; //记为无声段
;;;215    			}
;;;216    		}
;;;217    	}
;;;218    }
00019c  b007              ADD      sp,sp,#0x1c
00019e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.418|
0001a2  f04f0900          MOV      r9,#0                 ;207
0001a6  e004              B        |L1.434|
                  |L1.424|
0001a8  2a01              CMP      r2,#1                 ;210
0001aa  d102              BNE      |L1.434|
0001ac  f04f0800          MOV      r8,#0                 ;213
0001b0  2200              MOVS     r2,#0                 ;214
                  |L1.434|
0001b2  3050              ADDS     r0,r0,#0x50           ;121
                  |L1.436|
0001b4  f8ddb010          LDR      r11,[sp,#0x10]        ;121
0001b8  f1ab0ba0          SUB      r11,r11,#0xa0         ;121
0001bc  4583              CMP      r11,r0                ;121
0001be  f63faf4b          BHI      |L1.88|
0001c2  bf00              NOP      
0001c4  e7ea              B        |L1.412|
;;;219    
                          ENDP


                          AREA ||i.noise_atap||, CODE, READONLY, ALIGN=1

                  noise_atap PROC
;;;21     */
;;;22     void noise_atap(const u16* noise,u16 n_len,atap_tag* atap)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;23     {
000004  4603              MOV      r3,r0
;;;24     	u32 h,i;
;;;25     	u32	n_max;	
;;;26     	u32 max_sum;//每一帧噪声最大值 累加取平均 求噪声阈值
;;;27     	u32	n_sum;	//所有数值之和 求平均值 确定零(中)值
;;;28     	u32 mid;	//中值
;;;29     	u32 abs;	//绝对值
;;;30     	u32 abs_sum;//绝对值和
;;;31     	u32 frm_num;
;;;32     	
;;;33     	if((n_len%atap_frm_len)!=0)	//参数检查
000006  f04f0bf0          MOV      r11,#0xf0
00000a  fb91fefb          SDIV     lr,r1,r11
00000e  fb0b1b1e          MLS      r11,r11,lr,r1
000012  f1bb0f00          CMP      r11,#0
000016  d001              BEQ      |L2.28|
                  |L2.24|
;;;34     	{
;;;35     		return;
;;;36     	}
;;;37     	frm_num=n_len/atap_frm_len;
;;;38     	
;;;39     	n_sum=0;
;;;40     	max_sum=0;
;;;41     	for(i=0;i<n_len;i++)
;;;42     	{
;;;43     		n_sum+=*(noise+i);
;;;44     	}
;;;45     	mid=n_sum/i;
;;;46     	
;;;47     	abs_sum=0;
;;;48     	for(i=0;i<n_len;i+=atap_frm_len)
;;;49     	{
;;;50     		n_max=0;
;;;51     		for(h=0;h<atap_frm_len;h++)
;;;52     		{
;;;53     			abs=(*(noise+i+h)>mid)?(*(noise+i+h)-mid):(mid-*(noise+i+h));
;;;54     			if(abs>n_max)	//取每帧最大绝对值
;;;55     			{
;;;56     				n_max=abs;
;;;57     			}
;;;58     			abs_sum+=abs;
;;;59     		}
;;;60     		max_sum+=n_max;
;;;61     		//USART1_printf("n_max=%d ", n_max);
;;;62     		//USART1_printf("max_sum=%d\r\n", max_sum);
;;;63     	}
;;;64     	
;;;65     	abs_sum/=(n_len/frame_len);
;;;66     	max_sum/=frm_num;
;;;67     	atap->mid_val=mid;
;;;68     	atap->n_thl=max_sum*n_thl_ratio;
;;;69     	atap->s_thl=abs_sum*s_thl_ratio;
;;;70     	atap->z_thl=frame_len*z_thl_ratio/n_thl_ratio;
;;;71     }
000018  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.28|
00001c  f04f0bf0          MOV      r11,#0xf0             ;37
000020  fb91fafb          SDIV     r10,r1,r11            ;37
000024  f04f0c00          MOV      r12,#0                ;39
000028  2600              MOVS     r6,#0                 ;40
00002a  2000              MOVS     r0,#0                 ;41
00002c  e003              B        |L2.54|
                  |L2.46|
00002e  f833b010          LDRH     r11,[r3,r0,LSL #1]    ;43
000032  44dc              ADD      r12,r12,r11           ;43
000034  1c40              ADDS     r0,r0,#1              ;41
                  |L2.54|
000036  4288              CMP      r0,r1                 ;41
000038  d3f9              BCC      |L2.46|
00003a  fbbcf5f0          UDIV     r5,r12,r0             ;45
00003e  2700              MOVS     r7,#0                 ;47
000040  2000              MOVS     r0,#0                 ;48
000042  e020              B        |L2.134|
                  |L2.68|
000044  f04f0900          MOV      r9,#0                 ;50
000048  2400              MOVS     r4,#0                 ;51
00004a  e018              B        |L2.126|
                  |L2.76|
00004c  eb030b40          ADD      r11,r3,r0,LSL #1      ;53
000050  f83bb014          LDRH     r11,[r11,r4,LSL #1]   ;53
000054  45ab              CMP      r11,r5                ;53
000056  d906              BLS      |L2.102|
000058  eb030b40          ADD      r11,r3,r0,LSL #1      ;53
00005c  f83bb014          LDRH     r11,[r11,r4,LSL #1]   ;53
000060  ebab0b05          SUB      r11,r11,r5            ;53
000064  e005              B        |L2.114|
                  |L2.102|
000066  eb030b40          ADD      r11,r3,r0,LSL #1      ;53
00006a  f83bb014          LDRH     r11,[r11,r4,LSL #1]   ;53
00006e  eba50b0b          SUB      r11,r5,r11            ;53
                  |L2.114|
000072  46d8              MOV      r8,r11                ;53
000074  45c8              CMP      r8,r9                 ;54
000076  d900              BLS      |L2.122|
000078  46c1              MOV      r9,r8                 ;56
                  |L2.122|
00007a  4447              ADD      r7,r7,r8              ;58
00007c  1c64              ADDS     r4,r4,#1              ;51
                  |L2.126|
00007e  2cf0              CMP      r4,#0xf0              ;51
000080  d3e4              BCC      |L2.76|
000082  444e              ADD      r6,r6,r9              ;60
000084  30f0              ADDS     r0,r0,#0xf0           ;48
                  |L2.134|
000086  4288              CMP      r0,r1                 ;48
000088  d3dc              BCC      |L2.68|
00008a  f04f0ba0          MOV      r11,#0xa0             ;65
00008e  fb91fbfb          SDIV     r11,r1,r11            ;65
000092  fbb7f7fb          UDIV     r7,r7,r11             ;65
000096  fbb6f6fa          UDIV     r6,r6,r10             ;66
00009a  6015              STR      r5,[r2,#0]            ;67
00009c  8096              STRH     r6,[r2,#4]            ;68
00009e  eb070b47          ADD      r11,r7,r7,LSL #1      ;69
0000a2  eb0b0bc7          ADD      r11,r11,r7,LSL #3     ;69
0000a6  f04f0e0a          MOV      lr,#0xa               ;69
0000aa  fbbbfbfe          UDIV     r11,r11,lr            ;69
0000ae  f8c2b008          STR      r11,[r2,#8]           ;69
0000b2  f04f0b02          MOV      r11,#2                ;70
0000b6  f8a2b006          STRH     r11,[r2,#6]           ;70
0000ba  bf00              NOP      
0000bc  e7ac              B        |L2.24|
;;;72     #define	v_durmin_t	80	//有效语音最短时间门限 ms
                          ENDP

