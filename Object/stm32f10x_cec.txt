; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Object\stm32f10x_cec.o --depend=.\Object\stm32f10x_cec.d --feedback=.\Object\stm32-speech-recognition.fed --cpu=Cortex-M3 --apcs=interwork -O0 -Otime -I.\Src\APP -I.\Src\BSP -I.\Src\GUI -I.\Src\CM3_SYS -I.\Src\FATFS -I.\Src\StdPeriph_Driver -I.\Src\StdPeriph_Driver\inc -I.\Src\Speech_Recog -IE:\SoftWare\KEIL\Keil4\path\ARM\INC -IE:\SoftWare\KEIL\Keil4\path\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\Object\stm32f10x_cec.crf Src\StdPeriph_Driver\src\stm32f10x_cec.c]
                          THUMB

                          AREA ||i.CEC_ClearFlag||, CODE, READONLY, ALIGN=2

                  CEC_ClearFlag PROC
;;;347      */
;;;348    void CEC_ClearFlag(uint32_t CEC_FLAG)
000000  2100              MOVS     r1,#0
;;;349    { 
;;;350      uint32_t tmp = 0x0;
;;;351      
;;;352      /* Check the parameters */
;;;353      assert_param(IS_CEC_CLEAR_FLAG(CEC_FLAG));
;;;354    
;;;355      tmp = CEC->CSR & 0x2;
000002  4a09              LDR      r2,|L1.40|
000004  6812              LDR      r2,[r2,#0]
000006  f0020102          AND      r1,r2,#2
;;;356           
;;;357      /* Clear the selected CEC flags */
;;;358      CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_FLAG) & 0xFFFFFFFC) | tmp);
00000a  4a08              LDR      r2,|L1.44|
00000c  f8d23810          LDR      r3,[r2,#0x810]
000010  f06f0203          MVN      r2,#3
000014  ea220200          BIC      r2,r2,r0
000018  ea420201          ORR      r2,r2,r1
00001c  ea030302          AND      r3,r3,r2
000020  4a01              LDR      r2,|L1.40|
000022  6013              STR      r3,[r2,#0]
;;;359    }
000024  4770              BX       lr
;;;360    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x40007810
                  |L1.44|
                          DCD      0x40007000

                          AREA ||i.CEC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CEC_ClearITPendingBit PROC
;;;406      */
;;;407    void CEC_ClearITPendingBit(uint16_t CEC_IT)
000000  2100              MOVS     r1,#0
;;;408    {
;;;409      uint32_t tmp = 0x0;
;;;410      
;;;411      /* Check the parameters */
;;;412      assert_param(IS_CEC_GET_IT(CEC_IT));
;;;413      
;;;414      tmp = CEC->CSR & 0x2;
000002  4a09              LDR      r2,|L2.40|
000004  6812              LDR      r2,[r2,#0]
000006  f0020102          AND      r1,r2,#2
;;;415      
;;;416      /* Clear the selected CEC interrupt pending bits */
;;;417      CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_IT) & 0xFFFFFFFC) | tmp);
00000a  4a08              LDR      r2,|L2.44|
00000c  f8d23810          LDR      r3,[r2,#0x810]
000010  f06f0203          MVN      r2,#3
000014  ea220200          BIC      r2,r2,r0
000018  ea420201          ORR      r2,r2,r1
00001c  ea030302          AND      r3,r3,r2
000020  4a01              LDR      r2,|L2.40|
000022  6013              STR      r3,[r2,#0]
;;;418    }
000024  4770              BX       lr
;;;419    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40007810
                  |L2.44|
                          DCD      0x40007000

                          AREA ||i.CEC_Cmd||, CODE, READONLY, ALIGN=2

                  CEC_Cmd PROC
;;;162      */
;;;163    void CEC_Cmd(FunctionalState NewState)
000000  4904              LDR      r1,|L3.20|
;;;164    {
;;;165      /* Check the parameters */
;;;166      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;167    
;;;168      *(__IO uint32_t *) CFGR_PE_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;169    
;;;170      if(NewState == DISABLE)
000004  b928              CBNZ     r0,|L3.18|
;;;171      {
;;;172        /* Wait until the PE bit is cleared by hardware (Idle Line detected) */
;;;173        while((CEC->CFGR & CEC_CFGR_PE) != (uint32_t)RESET)
000006  bf00              NOP      
                  |L3.8|
000008  4903              LDR      r1,|L3.24|
00000a  6809              LDR      r1,[r1,#0]
00000c  f0110f01          TST      r1,#1
000010  d1fa              BNE      |L3.8|
                  |L3.18|
;;;174        {
;;;175        }  
;;;176      }  
;;;177    }
000012  4770              BX       lr
;;;178    
                          ENDP

                  |L3.20|
                          DCD      0x420f0000
                  |L3.24|
                          DCD      0x40007800

                          AREA ||i.CEC_DeInit||, CODE, READONLY, ALIGN=1

                  CEC_DeInit PROC
;;;116      */
;;;117    void CEC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119      /* Enable CEC reset state */
;;;120      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, ENABLE);  
000002  2101              MOVS     r1,#1
000004  0788              LSLS     r0,r1,#30
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;121      /* Release CEC from reset state */
;;;122      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, DISABLE); 
00000a  2100              MOVS     r1,#0
00000c  f04f4080          MOV      r0,#0x40000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;123    }
000014  bd10              POP      {r4,pc}
;;;124    
                          ENDP


                          AREA ||i.CEC_EndOfMessageCmd||, CODE, READONLY, ALIGN=2

                  CEC_EndOfMessageCmd PROC
;;;260      */
;;;261    void CEC_EndOfMessageCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L5.8|
;;;262    {   
;;;263      /* Check the parameters */
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;265      
;;;266      /* The data byte will be transmitted with or without an EOM bit*/
;;;267      *(__IO uint32_t *) CSR_TEOM_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;268    }
000004  4770              BX       lr
;;;269    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x420f0204

                          AREA ||i.CEC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CEC_GetFlagStatus PROC
;;;289      */
;;;290    FlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG) 
000000  b510              PUSH     {r4,lr}
;;;291    {
000002  4601              MOV      r1,r0
;;;292      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;293      uint32_t cecreg = 0, cecbase = 0;
000006  2300              MOVS     r3,#0
000008  2200              MOVS     r2,#0
;;;294      
;;;295      /* Check the parameters */
;;;296      assert_param(IS_CEC_GET_FLAG(CEC_FLAG));
;;;297     
;;;298      /* Get the CEC peripheral base address */
;;;299      cecbase = (uint32_t)(CEC_BASE);
00000a  4a08              LDR      r2,|L6.44|
;;;300      
;;;301      /* Read flag register index */
;;;302      cecreg = CEC_FLAG >> 28;
00000c  0f0b              LSRS     r3,r1,#28
;;;303      
;;;304      /* Get bit[23:0] of the flag */
;;;305      CEC_FLAG &= FLAG_Mask;
00000e  f021417f          BIC      r1,r1,#0xff000000
;;;306      
;;;307      if(cecreg != 0)
000012  b113              CBZ      r3,|L6.26|
;;;308      {
;;;309        /* Flag in CEC ESR Register */
;;;310        CEC_FLAG = (uint32_t)(CEC_FLAG >> 16);
000014  0c09              LSRS     r1,r1,#16
;;;311        
;;;312        /* Get the CEC ESR register address */
;;;313        cecbase += 0xC;
000016  320c              ADDS     r2,r2,#0xc
000018  e000              B        |L6.28|
                  |L6.26|
;;;314      }
;;;315      else
;;;316      {
;;;317        /* Get the CEC CSR register address */
;;;318        cecbase += 0x10;
00001a  3210              ADDS     r2,r2,#0x10
                  |L6.28|
;;;319      }
;;;320      
;;;321      if(((*(__IO uint32_t *)cecbase) & CEC_FLAG) != (uint32_t)RESET)
00001c  6814              LDR      r4,[r2,#0]
00001e  420c              TST      r4,r1
000020  d001              BEQ      |L6.38|
;;;322      {
;;;323        /* CEC_FLAG is set */
;;;324        bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L6.40|
                  |L6.38|
;;;325      }
;;;326      else
;;;327      {
;;;328        /* CEC_FLAG is reset */
;;;329        bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L6.40|
;;;330      }
;;;331      
;;;332      /* Return the CEC_FLAG status */
;;;333      return  bitstatus;
;;;334    }
000028  bd10              POP      {r4,pc}
;;;335    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40007800

                          AREA ||i.CEC_GetITStatus||, CODE, READONLY, ALIGN=2

                  CEC_GetITStatus PROC
;;;370      */
;;;371    ITStatus CEC_GetITStatus(uint8_t CEC_IT)
000000  4601              MOV      r1,r0
;;;372    {
;;;373      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;374      uint32_t enablestatus = 0;
000004  2200              MOVS     r2,#0
;;;375      
;;;376      /* Check the parameters */
;;;377       assert_param(IS_CEC_GET_IT(CEC_IT));
;;;378       
;;;379      /* Get the CEC IT enable bit status */
;;;380      enablestatus = (CEC->CFGR & (uint8_t)CEC_CFGR_IE) ;
000006  4b07              LDR      r3,|L7.36|
000008  681b              LDR      r3,[r3,#0]
00000a  f0030202          AND      r2,r3,#2
;;;381      
;;;382      /* Check the status of the specified CEC interrupt */
;;;383      if (((CEC->CSR & CEC_IT) != (uint32_t)RESET) && enablestatus)
00000e  4b06              LDR      r3,|L7.40|
000010  f8d33810          LDR      r3,[r3,#0x810]
000014  420b              TST      r3,r1
000016  d002              BEQ      |L7.30|
000018  b10a              CBZ      r2,|L7.30|
;;;384      {
;;;385        /* CEC_IT is set */
;;;386        bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L7.32|
                  |L7.30|
;;;387      }
;;;388      else
;;;389      {
;;;390        /* CEC_IT is reset */
;;;391        bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L7.32|
;;;392      }
;;;393      /* Return the CEC_IT status */
;;;394      return  bitstatus;
;;;395    }
000020  4770              BX       lr
;;;396    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x40007800
                  |L7.40|
                          DCD      0x40007000

                          AREA ||i.CEC_ITConfig||, CODE, READONLY, ALIGN=2

                  CEC_ITConfig PROC
;;;184      */
;;;185    void CEC_ITConfig(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;186    {
;;;187      /* Check the parameters */
;;;188      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;189    
;;;190      *(__IO uint32_t *) CFGR_IE_BB = (uint32_t)NewState;
000002  6048              STR      r0,[r1,#4]
;;;191    }
000004  4770              BX       lr
;;;192    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x420f0000

                          AREA ||i.CEC_Init||, CODE, READONLY, ALIGN=2

                  CEC_Init PROC
;;;133      */
;;;134    void CEC_Init(CEC_InitTypeDef* CEC_InitStruct)
000000  2100              MOVS     r1,#0
;;;135    {
;;;136      uint16_t tmpreg = 0;
;;;137     
;;;138      /* Check the parameters */
;;;139      assert_param(IS_CEC_BIT_TIMING_ERROR_MODE(CEC_InitStruct->CEC_BitTimingMode)); 
;;;140      assert_param(IS_CEC_BIT_PERIOD_ERROR_MODE(CEC_InitStruct->CEC_BitPeriodMode));
;;;141         
;;;142      /*---------------------------- CEC CFGR Configuration -----------------*/
;;;143      /* Get the CEC CFGR value */
;;;144      tmpreg = CEC->CFGR;
000002  4a07              LDR      r2,|L9.32|
000004  6812              LDR      r2,[r2,#0]
000006  b291              UXTH     r1,r2
;;;145      
;;;146      /* Clear BTEM and BPEM bits */
;;;147      tmpreg &= CFGR_CLEAR_Mask;
000008  f00101f3          AND      r1,r1,#0xf3
;;;148      
;;;149      /* Configure CEC: Bit Timing Error and Bit Period Error */
;;;150      tmpreg |= (uint16_t)(CEC_InitStruct->CEC_BitTimingMode | CEC_InitStruct->CEC_BitPeriodMode);
00000c  8802              LDRH     r2,[r0,#0]
00000e  8843              LDRH     r3,[r0,#2]
000010  ea420203          ORR      r2,r2,r3
000014  ea420101          ORR      r1,r2,r1
;;;151    
;;;152      /* Write to CEC CFGR  register*/
;;;153      CEC->CFGR = tmpreg;
000018  4a02              LDR      r2,|L9.36|
00001a  f8c21800          STR      r1,[r2,#0x800]
;;;154      
;;;155    }
00001e  4770              BX       lr
;;;156    
                          ENDP

                  |L9.32|
                          DCD      0x40007800
                  |L9.36|
                          DCD      0x40007000

                          AREA ||i.CEC_OwnAddressConfig||, CODE, READONLY, ALIGN=2

                  CEC_OwnAddressConfig PROC
;;;197      */
;;;198    void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress)
000000  4901              LDR      r1,|L10.8|
;;;199    {
;;;200      /* Check the parameters */
;;;201      assert_param(IS_CEC_ADDRESS(CEC_OwnAddress));
;;;202    
;;;203      /* Set the CEC own address */
;;;204      CEC->OAR = CEC_OwnAddress;
000002  6008              STR      r0,[r1,#0]
;;;205    }
000004  4770              BX       lr
;;;206    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40007804

                          AREA ||i.CEC_ReceiveDataByte||, CODE, READONLY, ALIGN=2

                  CEC_ReceiveDataByte PROC
;;;237      */
;;;238    uint8_t CEC_ReceiveDataByte(void)
000000  4801              LDR      r0,|L11.8|
;;;239    {
;;;240      /* Receive Data */
;;;241      return (uint8_t)(CEC->RXD);
000002  6800              LDR      r0,[r0,#0]
000004  b2c0              UXTB     r0,r0
;;;242    }
000006  4770              BX       lr
;;;243    
                          ENDP

                  |L11.8|
                          DCD      0x40007818

                          AREA ||i.CEC_SendDataByte||, CODE, READONLY, ALIGN=2

                  CEC_SendDataByte PROC
;;;225      */
;;;226    void CEC_SendDataByte(uint8_t Data)
000000  4901              LDR      r1,|L12.8|
;;;227    {  
;;;228      /* Transmit Data */
;;;229      CEC->TXD = Data ;
000002  6008              STR      r0,[r1,#0]
;;;230    }
000004  4770              BX       lr
;;;231    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40007814

                          AREA ||i.CEC_SetPrescaler||, CODE, READONLY, ALIGN=2

                  CEC_SetPrescaler PROC
;;;211      */
;;;212    void CEC_SetPrescaler(uint16_t CEC_Prescaler)
000000  4901              LDR      r1,|L13.8|
;;;213    {
;;;214      /* Check the parameters */
;;;215      assert_param(IS_CEC_PRESCALER(CEC_Prescaler));
;;;216    
;;;217      /* Set the  Prescaler value*/
;;;218      CEC->PRES = CEC_Prescaler;
000002  6008              STR      r0,[r1,#0]
;;;219    }
000004  4770              BX       lr
;;;220    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40007808

                          AREA ||i.CEC_StartOfMessage||, CODE, READONLY, ALIGN=2

                  CEC_StartOfMessage PROC
;;;248      */
;;;249    void CEC_StartOfMessage(void)
000000  2001              MOVS     r0,#1
;;;250    {  
;;;251      /* Starts of new message */
;;;252      *(__IO uint32_t *) CSR_TSOM_BB = (uint32_t)0x1;
000002  4901              LDR      r1,|L14.8|
000004  6008              STR      r0,[r1,#0]
;;;253    }
000006  4770              BX       lr
;;;254    
                          ENDP

                  |L14.8|
                          DCD      0x420f0200
