; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Object\stm32f10x_flash.o --depend=.\Object\stm32f10x_flash.d --feedback=.\Object\stm32-speech-recognition.fed --cpu=Cortex-M3 --apcs=interwork -O0 -Otime -I.\Src\APP -I.\Src\BSP -I.\Src\GUI -I.\Src\CM3_SYS -I.\Src\FATFS -I.\Src\StdPeriph_Driver -I.\Src\StdPeriph_Driver\inc -I.\Src\Speech_Recog -IE:\SoftWare\KEIL\Keil4\path\ARM\INC -IE:\SoftWare\KEIL\Keil4\path\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\Object\stm32f10x_flash.crf Src\StdPeriph_Driver\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1493     */
;;;1494   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;1495   {
;;;1496   #ifdef STM32F10X_XL
;;;1497     /* Check the parameters */
;;;1498     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1499   
;;;1500     if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1501     {
;;;1502       /* Clear the flags */
;;;1503       FLASH->SR2 = FLASH_FLAG;
;;;1504     }
;;;1505     else
;;;1506     {
;;;1507       /* Clear the flags */
;;;1508       FLASH->SR = FLASH_FLAG;
;;;1509     }  
;;;1510   
;;;1511   #else
;;;1512     /* Check the parameters */
;;;1513     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1514     
;;;1515     /* Clear the flags */
;;;1516     FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;1517   #endif /* STM32F10X_XL */
;;;1518   }
000004  4770              BX       lr
;;;1519   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;1025     */
;;;1026   FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1027   {
000004  4604              MOV      r4,r0
;;;1028     uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;1029     
;;;1030     FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;1031     
;;;1032     /* Check the parameters */
;;;1033     assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;1034     
;;;1035     FLASH_Pages = (uint32_t)(~FLASH_Pages);
000012  43e4              MVNS     r4,r4
;;;1036     WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000014  b2e6              UXTB     r6,r4
;;;1037     WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000016  f3c42707          UBFX     r7,r4,#8,#8
;;;1038     WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00001a  f3c44807          UBFX     r8,r4,#16,#8
;;;1039     WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
00001e  ea4f6914          LSR      r9,r4,#24
;;;1040     
;;;1041     /* Wait for last operation to be completed */
;;;1042     status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  02e8              LSLS     r0,r5,#11
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;1043     
;;;1044     if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d13e              BNE      |L2.172|
;;;1045     {
;;;1046       /* Authorizes the small information block programming */
;;;1047       FLASH->OPTKEYR = FLASH_KEY1;
00002e  4821              LDR      r0,|L2.180|
000030  4921              LDR      r1,|L2.184|
000032  6088              STR      r0,[r1,#8]
;;;1048       FLASH->OPTKEYR = FLASH_KEY2;
000034  4821              LDR      r0,|L2.188|
000036  6088              STR      r0,[r1,#8]
;;;1049       FLASH->CR |= CR_OPTPG_Set;
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;1050       if(WRP0_Data != 0xFF)
000042  2eff              CMP      r6,#0xff
000044  d006              BEQ      |L2.84|
;;;1051       {
;;;1052         OB->WRP0 = WRP0_Data;
000046  481e              LDR      r0,|L2.192|
000048  8006              STRH     r6,[r0,#0]
;;;1053         
;;;1054         /* Wait for last operation to be completed */
;;;1055         status = FLASH_WaitForLastOperation(ProgramTimeout);
00004a  f44f5000          MOV      r0,#0x2000
00004e  f7fffffe          BL       FLASH_WaitForLastOperation
000052  4605              MOV      r5,r0
                  |L2.84|
;;;1056       }
;;;1057       if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000054  2d04              CMP      r5,#4
000056  d108              BNE      |L2.106|
000058  2fff              CMP      r7,#0xff
00005a  d006              BEQ      |L2.106|
;;;1058       {
;;;1059         OB->WRP1 = WRP1_Data;
00005c  4819              LDR      r0,|L2.196|
00005e  8007              STRH     r7,[r0,#0]
;;;1060         
;;;1061         /* Wait for last operation to be completed */
;;;1062         status = FLASH_WaitForLastOperation(ProgramTimeout);
000060  f44f5000          MOV      r0,#0x2000
000064  f7fffffe          BL       FLASH_WaitForLastOperation
000068  4605              MOV      r5,r0
                  |L2.106|
;;;1063       }
;;;1064       if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
00006a  2d04              CMP      r5,#4
00006c  d109              BNE      |L2.130|
00006e  f1b80fff          CMP      r8,#0xff
000072  d006              BEQ      |L2.130|
;;;1065       {
;;;1066         OB->WRP2 = WRP2_Data;
000074  4814              LDR      r0,|L2.200|
000076  f8a0880c          STRH     r8,[r0,#0x80c]
;;;1067         
;;;1068         /* Wait for last operation to be completed */
;;;1069         status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  02e8              LSLS     r0,r5,#11
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
000080  4605              MOV      r5,r0
                  |L2.130|
;;;1070       }
;;;1071       
;;;1072       if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000082  2d04              CMP      r5,#4
000084  d109              BNE      |L2.154|
000086  f1b90fff          CMP      r9,#0xff
00008a  d006              BEQ      |L2.154|
;;;1073       {
;;;1074         OB->WRP3 = WRP3_Data;
00008c  480e              LDR      r0,|L2.200|
00008e  f8a0980e          STRH     r9,[r0,#0x80e]
;;;1075        
;;;1076         /* Wait for last operation to be completed */
;;;1077         status = FLASH_WaitForLastOperation(ProgramTimeout);
000092  02e8              LSLS     r0,r5,#11
000094  f7fffffe          BL       FLASH_WaitForLastOperation
000098  4605              MOV      r5,r0
                  |L2.154|
;;;1078       }
;;;1079             
;;;1080       if(status != FLASH_TIMEOUT)
00009a  2d05              CMP      r5,#5
00009c  d006              BEQ      |L2.172|
;;;1081       {
;;;1082         /* if the program operation is completed, disable the OPTPG Bit */
;;;1083         FLASH->CR &= CR_OPTPG_Reset;
00009e  4806              LDR      r0,|L2.184|
0000a0  6900              LDR      r0,[r0,#0x10]
0000a2  f64171ef          MOV      r1,#0x1fef
0000a6  4008              ANDS     r0,r0,r1
0000a8  4903              LDR      r1,|L2.184|
0000aa  6108              STR      r0,[r1,#0x10]
                  |L2.172|
;;;1084       }
;;;1085     } 
;;;1086     /* Return the write protection operation Status */
;;;1087     return status;       
0000ac  4628              MOV      r0,r5
;;;1088   }
0000ae  e8bd83f0          POP      {r4-r9,pc}
;;;1089   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L2.180|
                          DCD      0x45670123
                  |L2.184|
                          DCD      0x40022000
                  |L2.188|
                          DCD      0xcdef89ab
                  |L2.192|
                          DCD      0x1ffff808
                  |L2.196|
                          DCD      0x1ffff80a
                  |L2.200|
                          DCD      0x1ffff000

                          AREA ||i.FLASH_EraseAllBank1Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Pages PROC
;;;565      */
;;;566    FLASH_Status FLASH_EraseAllBank1Pages(void)
000000  b510              PUSH     {r4,lr}
;;;567    {
;;;568      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;569      /* Wait for last operation to be completed */
;;;570      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
00000c  4604              MOV      r4,r0
;;;571      
;;;572      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d118              BNE      |L3.68|
;;;573      {
;;;574        /* if the previous operation is completed, proceed to erase all pages */
;;;575         FLASH->CR |= CR_MER_Set;
000012  480d              LDR      r0,|L3.72|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490b              LDR      r1,|L3.72|
00001c  6108              STR      r0,[r1,#0x10]
;;;576         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;577        
;;;578        /* Wait for last operation to be completed */
;;;579        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000030  4604              MOV      r4,r0
;;;580        if(status != FLASH_TIMEOUT)
000032  2c05              CMP      r4,#5
000034  d006              BEQ      |L3.68|
;;;581        {
;;;582          /* if the erase operation is completed, disable the MER Bit */
;;;583          FLASH->CR &= CR_MER_Reset;
000036  4804              LDR      r0,|L3.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fb          MOV      r1,#0x1ffb
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L3.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L3.68|
;;;584        }
;;;585      }    
;;;586      /* Return the Erase Status */
;;;587      return status;
000044  4620              MOV      r0,r4
;;;588    }
000046  bd10              POP      {r4,pc}
;;;589    
                          ENDP

                  |L3.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;496      */
;;;497    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;498    {
;;;499      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;500    
;;;501    #ifdef STM32F10X_XL
;;;502      /* Wait for last operation to be completed */
;;;503      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;504      
;;;505      if(status == FLASH_COMPLETE)
;;;506      {
;;;507        /* if the previous operation is completed, proceed to erase all pages */
;;;508         FLASH->CR |= CR_MER_Set;
;;;509         FLASH->CR |= CR_STRT_Set;
;;;510        
;;;511        /* Wait for last operation to be completed */
;;;512        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;513        if(status != FLASH_TIMEOUT)
;;;514        {
;;;515          /* if the erase operation is completed, disable the MER Bit */
;;;516          FLASH->CR &= CR_MER_Reset;
;;;517        }
;;;518      }    
;;;519      if(status == FLASH_COMPLETE)
;;;520      {
;;;521        /* if the previous operation is completed, proceed to erase all pages */
;;;522         FLASH->CR2 |= CR_MER_Set;
;;;523         FLASH->CR2 |= CR_STRT_Set;
;;;524        
;;;525        /* Wait for last operation to be completed */
;;;526        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;527        if(status != FLASH_TIMEOUT)
;;;528        {
;;;529          /* if the erase operation is completed, disable the MER Bit */
;;;530          FLASH->CR2 &= CR_MER_Reset;
;;;531        }
;;;532      }
;;;533    #else
;;;534      /* Wait for last operation to be completed */
;;;535      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;536      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d118              BNE      |L4.68|
;;;537      {
;;;538        /* if the previous operation is completed, proceed to erase all pages */
;;;539         FLASH->CR |= CR_MER_Set;
000012  480d              LDR      r0,|L4.72|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490b              LDR      r1,|L4.72|
00001c  6108              STR      r0,[r1,#0x10]
;;;540         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;541        
;;;542        /* Wait for last operation to be completed */
;;;543        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;544        if(status != FLASH_TIMEOUT)
000032  2c05              CMP      r4,#5
000034  d006              BEQ      |L4.68|
;;;545        {
;;;546          /* if the erase operation is completed, disable the MER Bit */
;;;547          FLASH->CR &= CR_MER_Reset;
000036  4804              LDR      r0,|L4.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fb          MOV      r1,#0x1ffb
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L4.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L4.68|
;;;548        }
;;;549      }
;;;550    #endif /* STM32F10X_XL */
;;;551    
;;;552      /* Return the Erase Status */
;;;553      return status;
000044  4620              MOV      r0,r4
;;;554    }
000046  bd10              POP      {r4,pc}
;;;555    
                          ENDP

                  |L4.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;630      */
;;;631    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b530              PUSH     {r4,r5,lr}
;;;632    {
;;;633      uint16_t rdptmp = RDP_Key;
000002  25a5              MOVS     r5,#0xa5
;;;634    
;;;635      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;636    
;;;637      /* Get the actual read protection Option Byte value */ 
;;;638      if(FLASH_GetReadOutProtectionStatus() != RESET)
000006  f7fffffe          BL       FLASH_GetReadOutProtectionStatus
00000a  b100              CBZ      r0,|L5.14|
;;;639      {
;;;640        rdptmp = 0x00;  
00000c  2500              MOVS     r5,#0
                  |L5.14|
;;;641      }
;;;642    
;;;643      /* Wait for last operation to be completed */
;;;644      status = FLASH_WaitForLastOperation(EraseTimeout);
00000e  f44f2030          MOV      r0,#0xb0000
000012  f7fffffe          BL       FLASH_WaitForLastOperation
000016  4604              MOV      r4,r0
;;;645      if(status == FLASH_COMPLETE)
000018  2c04              CMP      r4,#4
00001a  d13b              BNE      |L5.148|
;;;646      {
;;;647        /* Authorize the small information block programming */
;;;648        FLASH->OPTKEYR = FLASH_KEY1;
00001c  481e              LDR      r0,|L5.152|
00001e  491f              LDR      r1,|L5.156|
000020  6088              STR      r0,[r1,#8]
;;;649        FLASH->OPTKEYR = FLASH_KEY2;
000022  481f              LDR      r0,|L5.160|
000024  6088              STR      r0,[r1,#8]
;;;650        
;;;651        /* if the previous operation is completed, proceed to erase the option bytes */
;;;652        FLASH->CR |= CR_OPTER_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6108              STR      r0,[r1,#0x10]
;;;653        FLASH->CR |= CR_STRT_Set;
000030  4608              MOV      r0,r1
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400040          ORR      r0,r0,#0x40
000038  6108              STR      r0,[r1,#0x10]
;;;654        /* Wait for last operation to be completed */
;;;655        status = FLASH_WaitForLastOperation(EraseTimeout);
00003a  f44f2030          MOV      r0,#0xb0000
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;656        
;;;657        if(status == FLASH_COMPLETE)
000044  2c04              CMP      r4,#4
000046  d11c              BNE      |L5.130|
;;;658        {
;;;659          /* if the erase operation is completed, disable the OPTER Bit */
;;;660          FLASH->CR &= CR_OPTER_Reset;
000048  4814              LDR      r0,|L5.156|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171df          MOV      r1,#0x1fdf
000050  4008              ANDS     r0,r0,r1
000052  4912              LDR      r1,|L5.156|
000054  6108              STR      r0,[r1,#0x10]
;;;661           
;;;662          /* Enable the Option Bytes Programming operation */
;;;663          FLASH->CR |= CR_OPTPG_Set;
000056  4608              MOV      r0,r1
000058  6900              LDR      r0,[r0,#0x10]
00005a  f0400010          ORR      r0,r0,#0x10
00005e  6108              STR      r0,[r1,#0x10]
;;;664          /* Restore the last read protection Option Byte value */
;;;665          OB->RDP = (uint16_t)rdptmp; 
000060  4810              LDR      r0,|L5.164|
000062  8005              STRH     r5,[r0,#0]
;;;666          /* Wait for last operation to be completed */
;;;667          status = FLASH_WaitForLastOperation(ProgramTimeout);
000064  f44f5000          MOV      r0,#0x2000
000068  f7fffffe          BL       FLASH_WaitForLastOperation
00006c  4604              MOV      r4,r0
;;;668     
;;;669          if(status != FLASH_TIMEOUT)
00006e  2c05              CMP      r4,#5
000070  d010              BEQ      |L5.148|
;;;670          {
;;;671            /* if the program operation is completed, disable the OPTPG Bit */
;;;672            FLASH->CR &= CR_OPTPG_Reset;
000072  480a              LDR      r0,|L5.156|
000074  6900              LDR      r0,[r0,#0x10]
000076  f64171ef          MOV      r1,#0x1fef
00007a  4008              ANDS     r0,r0,r1
00007c  4907              LDR      r1,|L5.156|
00007e  6108              STR      r0,[r1,#0x10]
000080  e008              B        |L5.148|
                  |L5.130|
;;;673          }
;;;674        }
;;;675        else
;;;676        {
;;;677          if (status != FLASH_TIMEOUT)
000082  2c05              CMP      r4,#5
000084  d006              BEQ      |L5.148|
;;;678          {
;;;679            /* Disable the OPTPG Bit */
;;;680            FLASH->CR &= CR_OPTPG_Reset;
000086  4805              LDR      r0,|L5.156|
000088  6900              LDR      r0,[r0,#0x10]
00008a  f64171ef          MOV      r1,#0x1fef
00008e  4008              ANDS     r0,r0,r1
000090  4902              LDR      r1,|L5.156|
000092  6108              STR      r0,[r1,#0x10]
                  |L5.148|
;;;681          }
;;;682        }  
;;;683      }
;;;684      /* Return the erase status */
;;;685      return status;
000094  4620              MOV      r0,r4
;;;686    }
000096  bd30              POP      {r4,r5,pc}
;;;687    
                          ENDP

                  |L5.152|
                          DCD      0x45670123
                  |L5.156|
                          DCD      0x40022000
                  |L5.160|
                          DCD      0xcdef89ab
                  |L5.164|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;417      */
;;;418    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b530              PUSH     {r4,r5,lr}
;;;419    {
000002  4605              MOV      r5,r0
;;;420      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;421      /* Check the parameters */
;;;422      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;423    
;;;424    #ifdef STM32F10X_XL
;;;425      if(Page_Address < FLASH_BANK1_END_ADDRESS)  
;;;426      {
;;;427        /* Wait for last operation to be completed */
;;;428        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;429        if(status == FLASH_COMPLETE)
;;;430        { 
;;;431          /* if the previous operation is completed, proceed to erase the page */
;;;432          FLASH->CR|= CR_PER_Set;
;;;433          FLASH->AR = Page_Address; 
;;;434          FLASH->CR|= CR_STRT_Set;
;;;435        
;;;436          /* Wait for last operation to be completed */
;;;437          status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;438          if(status != FLASH_TIMEOUT)
;;;439          {
;;;440            /* if the erase operation is completed, disable the PER Bit */
;;;441            FLASH->CR &= CR_PER_Reset;
;;;442          }
;;;443        }
;;;444      }
;;;445      else
;;;446      {
;;;447        /* Wait for last operation to be completed */
;;;448        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;449        if(status == FLASH_COMPLETE)
;;;450        { 
;;;451          /* if the previous operation is completed, proceed to erase the page */
;;;452          FLASH->CR2|= CR_PER_Set;
;;;453          FLASH->AR2 = Page_Address; 
;;;454          FLASH->CR2|= CR_STRT_Set;
;;;455        
;;;456          /* Wait for last operation to be completed */
;;;457          status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;458          if(status != FLASH_TIMEOUT)
;;;459          {
;;;460            /* if the erase operation is completed, disable the PER Bit */
;;;461            FLASH->CR2 &= CR_PER_Reset;
;;;462          }
;;;463        }
;;;464      }
;;;465    #else
;;;466      /* Wait for last operation to be completed */
;;;467      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f44f2030          MOV      r0,#0xb0000
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;468      
;;;469      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d119              BNE      |L6.72|
;;;470      { 
;;;471        /* if the previous operation is completed, proceed to erase the page */
;;;472        FLASH->CR|= CR_PER_Set;
000014  480d              LDR      r0,|L6.76|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400002          ORR      r0,r0,#2
00001c  490b              LDR      r1,|L6.76|
00001e  6108              STR      r0,[r1,#0x10]
;;;473        FLASH->AR = Page_Address; 
000020  4608              MOV      r0,r1
000022  6145              STR      r5,[r0,#0x14]
;;;474        FLASH->CR|= CR_STRT_Set;
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6108              STR      r0,[r1,#0x10]
;;;475        
;;;476        /* Wait for last operation to be completed */
;;;477        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  f44f2030          MOV      r0,#0xb0000
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4604              MOV      r4,r0
;;;478        if(status != FLASH_TIMEOUT)
000036  2c05              CMP      r4,#5
000038  d006              BEQ      |L6.72|
;;;479        {
;;;480          /* if the erase operation is completed, disable the PER Bit */
;;;481          FLASH->CR &= CR_PER_Reset;
00003a  4804              LDR      r0,|L6.76|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f64171fd          MOV      r1,#0x1ffd
000042  4008              ANDS     r0,r0,r1
000044  4901              LDR      r1,|L6.76|
000046  6108              STR      r0,[r1,#0x10]
                  |L6.72|
;;;482        }
;;;483      }
;;;484    #endif /* STM32F10X_XL */
;;;485    
;;;486      /* Return the Erase Status */
;;;487      return status;
000048  4620              MOV      r0,r4
;;;488    }
00004a  bd30              POP      {r4,r5,pc}
;;;489    
                          ENDP

                  |L6.76|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank1Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank1Status PROC
;;;1565     */
;;;1566   FLASH_Status FLASH_GetBank1Status(void)
000000  2004              MOVS     r0,#4
;;;1567   {
;;;1568     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1569     
;;;1570     if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
000002  490c              LDR      r1,|L7.52|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  2901              CMP      r1,#1
00000c  d101              BNE      |L7.18|
;;;1571     {
;;;1572       flashstatus = FLASH_BUSY;
00000e  2001              MOVS     r0,#1
000010  e00e              B        |L7.48|
                  |L7.18|
;;;1573     }
;;;1574     else 
;;;1575     {  
;;;1576       if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
000012  4908              LDR      r1,|L7.52|
000014  68c9              LDR      r1,[r1,#0xc]
000016  f0110f04          TST      r1,#4
00001a  d001              BEQ      |L7.32|
;;;1577       { 
;;;1578         flashstatus = FLASH_ERROR_PG;
00001c  2002              MOVS     r0,#2
00001e  e007              B        |L7.48|
                  |L7.32|
;;;1579       }
;;;1580       else 
;;;1581       {
;;;1582         if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
000020  4904              LDR      r1,|L7.52|
000022  68c9              LDR      r1,[r1,#0xc]
000024  f0110f10          TST      r1,#0x10
000028  d001              BEQ      |L7.46|
;;;1583         {
;;;1584           flashstatus = FLASH_ERROR_WRP;
00002a  2003              MOVS     r0,#3
00002c  e000              B        |L7.48|
                  |L7.46|
;;;1585         }
;;;1586         else
;;;1587         {
;;;1588           flashstatus = FLASH_COMPLETE;
00002e  2004              MOVS     r0,#4
                  |L7.48|
;;;1589         }
;;;1590       }
;;;1591     }
;;;1592     /* Return the Flash Status */
;;;1593     return flashstatus;
;;;1594   }
000030  4770              BX       lr
;;;1595   
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1407     */
;;;1408   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;1409   {
;;;1410     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1411   
;;;1412   #ifdef STM32F10X_XL
;;;1413     /* Check the parameters */
;;;1414     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1415     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1416     {
;;;1417       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
;;;1418       {
;;;1419         bitstatus = SET;
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423         bitstatus = RESET;
;;;1424       }
;;;1425     }
;;;1426     else
;;;1427     {
;;;1428       if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1429       {
;;;1430         if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
;;;1431         {
;;;1432           bitstatus = SET;
;;;1433         }
;;;1434         else
;;;1435         {
;;;1436           bitstatus = RESET;
;;;1437         }
;;;1438       }
;;;1439       else
;;;1440       {
;;;1441         if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1442         {
;;;1443           bitstatus = SET;
;;;1444         }
;;;1445         else
;;;1446         {
;;;1447           bitstatus = RESET;
;;;1448         }
;;;1449       }
;;;1450     }
;;;1451   #else
;;;1452     /* Check the parameters */
;;;1453     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1454     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000004  2901              CMP      r1,#1
000006  d108              BNE      |L8.26|
;;;1455     {
;;;1456       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000008  4a08              LDR      r2,|L8.44|
00000a  69d2              LDR      r2,[r2,#0x1c]
00000c  f0120f01          TST      r2,#1
000010  d001              BEQ      |L8.22|
;;;1457       {
;;;1458         bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e008              B        |L8.40|
                  |L8.22|
;;;1459       }
;;;1460       else
;;;1461       {
;;;1462         bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e006              B        |L8.40|
                  |L8.26|
;;;1463       }
;;;1464     }
;;;1465     else
;;;1466     {
;;;1467      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00001a  4a04              LDR      r2,|L8.44|
00001c  68d2              LDR      r2,[r2,#0xc]
00001e  420a              TST      r2,r1
000020  d001              BEQ      |L8.38|
;;;1468       {
;;;1469         bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L8.40|
                  |L8.38|
;;;1470       }
;;;1471       else
;;;1472       {
;;;1473         bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L8.40|
;;;1474       }
;;;1475     }
;;;1476   #endif /* STM32F10X_XL */
;;;1477   
;;;1478     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1479     return bitstatus;
;;;1480   }
000028  4770              BX       lr
;;;1481   
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;1310     */
;;;1311   FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;1312   {
;;;1313     FlagStatus bitstatus = RESET;
;;;1314     
;;;1315     if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L9.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0110f20          TST      r1,#0x20
00000a  d001              BEQ      |L9.16|
;;;1316     {
;;;1317       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;1318     }
;;;1319     else
;;;1320     {
;;;1321       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;1322     }
;;;1323     /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;1324     return bitstatus; 
;;;1325   }
000012  4770              BX       lr
;;;1326   
                          ENDP

                  |L9.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;1290     */
;;;1291   FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;1292   {
;;;1293     FlagStatus readoutstatus = RESET;
;;;1294     if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L10.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0110f02          TST      r1,#2
00000a  d001              BEQ      |L10.16|
;;;1295     {
;;;1296       readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;1297     }
;;;1298     else
;;;1299     {
;;;1300       readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;1301     }
;;;1302     return readoutstatus;
;;;1303   }
000012  4770              BX       lr
;;;1304   
                          ENDP

                  |L10.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1527     */
;;;1528   FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;1529   {
;;;1530     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1531     
;;;1532     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490c              LDR      r1,|L11.52|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  2901              CMP      r1,#1
00000c  d101              BNE      |L11.18|
;;;1533     {
;;;1534       flashstatus = FLASH_BUSY;
00000e  2001              MOVS     r0,#1
000010  e00e              B        |L11.48|
                  |L11.18|
;;;1535     }
;;;1536     else 
;;;1537     {  
;;;1538       if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
000012  4908              LDR      r1,|L11.52|
000014  68c9              LDR      r1,[r1,#0xc]
000016  f0110f04          TST      r1,#4
00001a  d001              BEQ      |L11.32|
;;;1539       { 
;;;1540         flashstatus = FLASH_ERROR_PG;
00001c  2002              MOVS     r0,#2
00001e  e007              B        |L11.48|
                  |L11.32|
;;;1541       }
;;;1542       else 
;;;1543       {
;;;1544         if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
000020  4904              LDR      r1,|L11.52|
000022  68c9              LDR      r1,[r1,#0xc]
000024  f0110f10          TST      r1,#0x10
000028  d001              BEQ      |L11.46|
;;;1545         {
;;;1546           flashstatus = FLASH_ERROR_WRP;
00002a  2003              MOVS     r0,#3
00002c  e000              B        |L11.48|
                  |L11.46|
;;;1547         }
;;;1548         else
;;;1549         {
;;;1550           flashstatus = FLASH_COMPLETE;
00002e  2004              MOVS     r0,#4
                  |L11.48|
;;;1551         }
;;;1552       }
;;;1553     }
;;;1554     /* Return the Flash Status */
;;;1555     return flashstatus;
;;;1556   }
000030  4770              BX       lr
;;;1557   
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;1266     */
;;;1267   uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L12.8|
;;;1268   {
;;;1269     /* Return the User Option Byte */
;;;1270     return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;1271   }
000006  4770              BX       lr
;;;1272   
                          ENDP

                  |L12.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;1278     */
;;;1279   uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L13.8|
;;;1280   {
;;;1281     /* Return the Falsh write protection Register value */
;;;1282     return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;1283   }
000004  4770              BX       lr
;;;1284   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;279      */
;;;280    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4905              LDR      r1,|L14.24|
;;;281    {
;;;282      /* Check the parameters */
;;;283      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;284      
;;;285      /* Enable or disable the Half cycle access */
;;;286      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210108          BIC      r1,r1,#8
000008  4a03              LDR      r2,|L14.24|
00000a  6011              STR      r1,[r2,#0]
;;;287      FLASH->ACR |= FLASH_HalfCycleAccess;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;288    }
000014  4770              BX       lr
;;;289    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1340     */
;;;1341   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L15.14|
;;;1342   {
;;;1343   #ifdef STM32F10X_XL
;;;1344     /* Check the parameters */
;;;1345     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1346     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1347   
;;;1348     if((FLASH_IT & 0x80000000) != 0x0)
;;;1349     {
;;;1350       if(NewState != DISABLE)
;;;1351       {
;;;1352         /* Enable the interrupt sources */
;;;1353         FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
;;;1354       }
;;;1355       else
;;;1356       {
;;;1357         /* Disable the interrupt sources */
;;;1358         FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
;;;1359       }
;;;1360     }
;;;1361     else
;;;1362     {
;;;1363       if(NewState != DISABLE)
;;;1364       {
;;;1365         /* Enable the interrupt sources */
;;;1366         FLASH->CR |= FLASH_IT;
;;;1367       }
;;;1368       else
;;;1369       {
;;;1370         /* Disable the interrupt sources */
;;;1371         FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1372       }
;;;1373     }
;;;1374   #else
;;;1375     /* Check the parameters */
;;;1376     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1377     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1378   
;;;1379     if(NewState != DISABLE)
;;;1380     {
;;;1381       /* Enable the interrupt sources */
;;;1382       FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L15.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L15.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L15.24|
                  |L15.14|
;;;1383     }
;;;1384     else
;;;1385     {
;;;1386       /* Disable the interrupt sources */
;;;1387       FLASH->CR &= ~(uint32_t)FLASH_IT;
00000e  4a03              LDR      r2,|L15.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L15.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L15.24|
;;;1388     }
;;;1389   #endif /* STM32F10X_XL */
;;;1390   }
000018  4770              BX       lr
;;;1391   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;370      */
;;;371    void FLASH_Lock(void)
000000  4803              LDR      r0,|L16.16|
;;;372    {
;;;373      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;374      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L16.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;375    
;;;376    #ifdef STM32F10X_XL
;;;377      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;378      FLASH->CR2 |= CR_LOCK_Set;
;;;379    #endif /* STM32F10X_XL */
;;;380    }
00000c  4770              BX       lr
;;;381    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank1 PROC
;;;390      */
;;;391    void FLASH_LockBank1(void)
000000  4803              LDR      r0,|L17.16|
;;;392    {
;;;393      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;394      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L17.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;395    }
00000c  4770              BX       lr
;;;396    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;298      */
;;;299    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4905              LDR      r1,|L18.24|
;;;300    {
;;;301      /* Check the parameters */
;;;302      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;303      
;;;304      /* Enable or disable the Prefetch Buffer */
;;;305      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L18.24|
00000a  6011              STR      r1,[r2,#0]
;;;306      FLASH->ACR |= FLASH_PrefetchBuffer;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;307    }
000014  4770              BX       lr
;;;308    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;902      */
;;;903    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;904    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;905      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;906      /* Check the parameters */
;;;907      assert_param(IS_FLASH_ADDRESS(Address));
;;;908    
;;;909    #ifdef STM32F10X_XL
;;;910      /* Wait for last operation to be completed */
;;;911      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;912      
;;;913      if(Address < FLASH_BANK1_END_ADDRESS)
;;;914      {
;;;915        if(status == FLASH_COMPLETE)
;;;916        {
;;;917          /* if the previous operation is completed, proceed to program the new data */
;;;918          FLASH->CR |= CR_PG_Set;
;;;919      
;;;920          *(__IO uint16_t*)Address = Data;
;;;921          /* Wait for last operation to be completed */
;;;922          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;923          if(status != FLASH_TIMEOUT)
;;;924          {
;;;925            /* if the program operation is completed, disable the PG Bit */
;;;926            FLASH->CR &= CR_PG_Reset;
;;;927          }
;;;928        }
;;;929      }
;;;930      else
;;;931      {
;;;932        if(status == FLASH_COMPLETE)
;;;933        {
;;;934          /* if the previous operation is completed, proceed to program the new data */
;;;935          FLASH->CR2 |= CR_PG_Set;
;;;936      
;;;937          *(__IO uint16_t*)Address = Data;
;;;938          /* Wait for last operation to be completed */
;;;939          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;940          if(status != FLASH_TIMEOUT)
;;;941          {
;;;942            /* if the program operation is completed, disable the PG Bit */
;;;943            FLASH->CR2 &= CR_PG_Reset;
;;;944          }
;;;945        }
;;;946      }
;;;947    #else
;;;948      /* Wait for last operation to be completed */
;;;949      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  02e0              LSLS     r0,r4,#11
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;950      
;;;951      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d113              BNE      |L19.60|
;;;952      {
;;;953        /* if the previous operation is completed, proceed to program the new data */
;;;954        FLASH->CR |= CR_PG_Set;
000014  480a              LDR      r0,|L19.64|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4908              LDR      r1,|L19.64|
00001e  6108              STR      r0,[r1,#0x10]
;;;955      
;;;956        *(__IO uint16_t*)Address = Data;
000020  802e              STRH     r6,[r5,#0]
;;;957        /* Wait for last operation to be completed */
;;;958        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  02e0              LSLS     r0,r4,#11
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4604              MOV      r4,r0
;;;959        if(status != FLASH_TIMEOUT)
00002a  2c05              CMP      r4,#5
00002c  d006              BEQ      |L19.60|
;;;960        {
;;;961          /* if the program operation is completed, disable the PG Bit */
;;;962          FLASH->CR &= CR_PG_Reset;
00002e  4804              LDR      r0,|L19.64|
000030  6900              LDR      r0,[r0,#0x10]
000032  f64171fe          MOV      r1,#0x1ffe
000036  4008              ANDS     r0,r0,r1
000038  4901              LDR      r1,|L19.64|
00003a  6108              STR      r0,[r1,#0x10]
                  |L19.60|
;;;963        }
;;;964      } 
;;;965    #endif  /* STM32F10X_XL */
;;;966      
;;;967      /* Return the Program Status */
;;;968      return status;
00003c  4620              MOV      r0,r4
;;;969    }
00003e  bd70              POP      {r4-r6,pc}
;;;970    
                          ENDP

                  |L19.64|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;979      */
;;;980    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;981    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;982      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;983      /* Check the parameters */
;;;984      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;985      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  02e0              LSLS     r0,r4,#11
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;986    
;;;987      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d117              BNE      |L20.68|
;;;988      {
;;;989        /* Authorize the small information block programming */
;;;990        FLASH->OPTKEYR = FLASH_KEY1;
000014  480c              LDR      r0,|L20.72|
000016  490d              LDR      r1,|L20.76|
000018  6088              STR      r0,[r1,#8]
;;;991        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480d              LDR      r0,|L20.80|
00001c  6088              STR      r0,[r1,#8]
;;;992        /* Enables the Option Bytes Programming operation */
;;;993        FLASH->CR |= CR_OPTPG_Set; 
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400010          ORR      r0,r0,#0x10
000026  6108              STR      r0,[r1,#0x10]
;;;994        *(__IO uint16_t*)Address = Data;
000028  802e              STRH     r6,[r5,#0]
;;;995        
;;;996        /* Wait for last operation to be completed */
;;;997        status = FLASH_WaitForLastOperation(ProgramTimeout);
00002a  02e0              LSLS     r0,r4,#11
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;998        if(status != FLASH_TIMEOUT)
000032  2c05              CMP      r4,#5
000034  d006              BEQ      |L20.68|
;;;999        {
;;;1000         /* if the program operation is completed, disable the OPTPG Bit */
;;;1001         FLASH->CR &= CR_OPTPG_Reset;
000036  4805              LDR      r0,|L20.76|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171ef          MOV      r1,#0x1fef
00003e  4008              ANDS     r0,r0,r1
000040  4902              LDR      r1,|L20.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L20.68|
;;;1002       }
;;;1003     }
;;;1004     /* Return the Option Byte Data Program Status */
;;;1005     return status;
000044  4620              MOV      r0,r4
;;;1006   }
000046  bd70              POP      {r4-r6,pc}
;;;1007   
                          ENDP

                  |L20.72|
                          DCD      0x45670123
                  |L20.76|
                          DCD      0x40022000
                  |L20.80|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;695      */
;;;696    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;697    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;698      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;699      __IO uint32_t tmp = 0;
000008  2700              MOVS     r7,#0
;;;700    
;;;701      /* Check the parameters */
;;;702      assert_param(IS_FLASH_ADDRESS(Address));
;;;703    
;;;704    #ifdef STM32F10X_XL
;;;705      if(Address < FLASH_BANK1_END_ADDRESS - 2)
;;;706      { 
;;;707        /* Wait for last operation to be completed */
;;;708        status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
;;;709        if(status == FLASH_COMPLETE)
;;;710        {
;;;711          /* if the previous operation is completed, proceed to program the new first 
;;;712            half word */
;;;713          FLASH->CR |= CR_PG_Set;
;;;714      
;;;715          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;716          /* Wait for last operation to be completed */
;;;717          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;718     
;;;719          if(status == FLASH_COMPLETE)
;;;720          {
;;;721            /* if the previous operation is completed, proceed to program the new second 
;;;722            half word */
;;;723            tmp = Address + 2;
;;;724    
;;;725            *(__IO uint16_t*) tmp = Data >> 16;
;;;726        
;;;727            /* Wait for last operation to be completed */
;;;728            status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;729            
;;;730            if(status != FLASH_TIMEOUT)
;;;731            {
;;;732              /* Disable the PG Bit */
;;;733              FLASH->CR &= CR_PG_Reset;
;;;734            }
;;;735          }
;;;736          else
;;;737          {
;;;738            if (status != FLASH_TIMEOUT)
;;;739            {
;;;740              /* Disable the PG Bit */
;;;741              FLASH->CR &= CR_PG_Reset;
;;;742            }
;;;743           }
;;;744        }
;;;745      }
;;;746      else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
;;;747      {
;;;748        /* Wait for last operation to be completed */
;;;749        status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;750    
;;;751        if(status == FLASH_COMPLETE)
;;;752        {
;;;753          /* if the previous operation is completed, proceed to program the new first 
;;;754            half word */
;;;755          FLASH->CR |= CR_PG_Set;
;;;756      
;;;757          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;758    
;;;759          /* Wait for last operation to be completed */
;;;760          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;761    
;;;762          if(status != FLASH_TIMEOUT)
;;;763          {
;;;764            /* Disable the PG Bit */
;;;765            FLASH->CR &= CR_PG_Reset;
;;;766          }
;;;767        }
;;;768        else
;;;769        {
;;;770          if (status != FLASH_TIMEOUT)
;;;771          {
;;;772            /* Disable the PG Bit */
;;;773            FLASH->CR &= CR_PG_Reset;
;;;774          }
;;;775        }
;;;776    
;;;777        /* Wait for last operation to be completed */
;;;778        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;779    
;;;780        if(status == FLASH_COMPLETE)
;;;781        {
;;;782          /* if the previous operation is completed, proceed to program the new second 
;;;783          half word */
;;;784          FLASH->CR2 |= CR_PG_Set;
;;;785          tmp = Address + 2;
;;;786    
;;;787          *(__IO uint16_t*) tmp = Data >> 16;
;;;788        
;;;789          /* Wait for last operation to be completed */
;;;790          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;791            
;;;792          if(status != FLASH_TIMEOUT)
;;;793          {
;;;794            /* Disable the PG Bit */
;;;795            FLASH->CR2 &= CR_PG_Reset;
;;;796          }
;;;797        }
;;;798        else
;;;799        {
;;;800          if (status != FLASH_TIMEOUT)
;;;801          {
;;;802            /* Disable the PG Bit */
;;;803            FLASH->CR2 &= CR_PG_Reset;
;;;804          }
;;;805        }
;;;806      }
;;;807      else
;;;808      {
;;;809        /* Wait for last operation to be completed */
;;;810        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;811    
;;;812        if(status == FLASH_COMPLETE)
;;;813        {
;;;814          /* if the previous operation is completed, proceed to program the new first 
;;;815            half word */
;;;816          FLASH->CR2 |= CR_PG_Set;
;;;817      
;;;818          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;819          /* Wait for last operation to be completed */
;;;820          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;821     
;;;822          if(status == FLASH_COMPLETE)
;;;823          {
;;;824            /* if the previous operation is completed, proceed to program the new second 
;;;825            half word */
;;;826            tmp = Address + 2;
;;;827    
;;;828            *(__IO uint16_t*) tmp = Data >> 16;
;;;829        
;;;830            /* Wait for last operation to be completed */
;;;831            status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;832            
;;;833            if(status != FLASH_TIMEOUT)
;;;834            {
;;;835              /* Disable the PG Bit */
;;;836              FLASH->CR2 &= CR_PG_Reset;
;;;837            }
;;;838          }
;;;839          else
;;;840          {
;;;841            if (status != FLASH_TIMEOUT)
;;;842            {
;;;843              /* Disable the PG Bit */
;;;844              FLASH->CR2 &= CR_PG_Reset;
;;;845            }
;;;846          }
;;;847        }
;;;848      }
;;;849    #else
;;;850      /* Wait for last operation to be completed */
;;;851      status = FLASH_WaitForLastOperation(ProgramTimeout);
00000a  02e0              LSLS     r0,r4,#11
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
000010  4604              MOV      r4,r0
;;;852      
;;;853      if(status == FLASH_COMPLETE)
000012  2c04              CMP      r4,#4
000014  d126              BNE      |L21.100|
;;;854      {
;;;855        /* if the previous operation is completed, proceed to program the new first 
;;;856        half word */
;;;857        FLASH->CR |= CR_PG_Set;
000016  4814              LDR      r0,|L21.104|
000018  6900              LDR      r0,[r0,#0x10]
00001a  f0400001          ORR      r0,r0,#1
00001e  4912              LDR      r1,|L21.104|
000020  6108              STR      r0,[r1,#0x10]
;;;858      
;;;859        *(__IO uint16_t*)Address = (uint16_t)Data;
000022  802e              STRH     r6,[r5,#0]
;;;860        /* Wait for last operation to be completed */
;;;861        status = FLASH_WaitForLastOperation(ProgramTimeout);
000024  02e0              LSLS     r0,r4,#11
000026  f7fffffe          BL       FLASH_WaitForLastOperation
00002a  4604              MOV      r4,r0
;;;862     
;;;863        if(status == FLASH_COMPLETE)
00002c  2c04              CMP      r4,#4
00002e  d110              BNE      |L21.82|
;;;864        {
;;;865          /* if the previous operation is completed, proceed to program the new second 
;;;866          half word */
;;;867          tmp = Address + 2;
000030  1caf              ADDS     r7,r5,#2
;;;868    
;;;869          *(__IO uint16_t*) tmp = Data >> 16;
000032  0c30              LSRS     r0,r6,#16
000034  8038              STRH     r0,[r7,#0]
;;;870        
;;;871          /* Wait for last operation to be completed */
;;;872          status = FLASH_WaitForLastOperation(ProgramTimeout);
000036  02e0              LSLS     r0,r4,#11
000038  f7fffffe          BL       FLASH_WaitForLastOperation
00003c  4604              MOV      r4,r0
;;;873            
;;;874          if(status != FLASH_TIMEOUT)
00003e  2c05              CMP      r4,#5
000040  d010              BEQ      |L21.100|
;;;875          {
;;;876            /* Disable the PG Bit */
;;;877            FLASH->CR &= CR_PG_Reset;
000042  4809              LDR      r0,|L21.104|
000044  6900              LDR      r0,[r0,#0x10]
000046  f64171fe          MOV      r1,#0x1ffe
00004a  4008              ANDS     r0,r0,r1
00004c  4906              LDR      r1,|L21.104|
00004e  6108              STR      r0,[r1,#0x10]
000050  e008              B        |L21.100|
                  |L21.82|
;;;878          }
;;;879        }
;;;880        else
;;;881        {
;;;882          if (status != FLASH_TIMEOUT)
000052  2c05              CMP      r4,#5
000054  d006              BEQ      |L21.100|
;;;883          {
;;;884            /* Disable the PG Bit */
;;;885            FLASH->CR &= CR_PG_Reset;
000056  4804              LDR      r0,|L21.104|
000058  6900              LDR      r0,[r0,#0x10]
00005a  f64171fe          MOV      r1,#0x1ffe
00005e  4008              ANDS     r0,r0,r1
000060  4901              LDR      r1,|L21.104|
000062  6108              STR      r0,[r1,#0x10]
                  |L21.100|
;;;886          }
;;;887        }
;;;888      }         
;;;889    #endif /* STM32F10X_XL */
;;;890       
;;;891      /* Return the Program Status */
;;;892      return status;
000064  4620              MOV      r0,r4
;;;893    }
000066  bdf0              POP      {r4-r7,pc}
;;;894    
                          ENDP

                  |L21.104|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;1099     */
;;;1100   FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1101   {
000002  4605              MOV      r5,r0
;;;1102     FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;1103     /* Check the parameters */
;;;1104     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1105     status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f44f2030          MOV      r0,#0xb0000
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;1106     if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d141              BNE      |L22.152|
;;;1107     {
;;;1108       /* Authorizes the small information block programming */
;;;1109       FLASH->OPTKEYR = FLASH_KEY1;
000014  4821              LDR      r0,|L22.156|
000016  4922              LDR      r1,|L22.160|
000018  6088              STR      r0,[r1,#8]
;;;1110       FLASH->OPTKEYR = FLASH_KEY2;
00001a  4822              LDR      r0,|L22.164|
00001c  6088              STR      r0,[r1,#8]
;;;1111       FLASH->CR |= CR_OPTER_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400020          ORR      r0,r0,#0x20
000026  6108              STR      r0,[r1,#0x10]
;;;1112       FLASH->CR |= CR_STRT_Set;
000028  4608              MOV      r0,r1
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6108              STR      r0,[r1,#0x10]
;;;1113       /* Wait for last operation to be completed */
;;;1114       status = FLASH_WaitForLastOperation(EraseTimeout);
000032  f44f2030          MOV      r0,#0xb0000
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  4604              MOV      r4,r0
;;;1115       if(status == FLASH_COMPLETE)
00003c  2c04              CMP      r4,#4
00003e  d122              BNE      |L22.134|
;;;1116       {
;;;1117         /* if the erase operation is completed, disable the OPTER Bit */
;;;1118         FLASH->CR &= CR_OPTER_Reset;
000040  4817              LDR      r0,|L22.160|
000042  6900              LDR      r0,[r0,#0x10]
000044  f64171df          MOV      r1,#0x1fdf
000048  4008              ANDS     r0,r0,r1
00004a  4915              LDR      r1,|L22.160|
00004c  6108              STR      r0,[r1,#0x10]
;;;1119         /* Enable the Option Bytes Programming operation */
;;;1120         FLASH->CR |= CR_OPTPG_Set; 
00004e  4608              MOV      r0,r1
000050  6900              LDR      r0,[r0,#0x10]
000052  f0400010          ORR      r0,r0,#0x10
000056  6108              STR      r0,[r1,#0x10]
;;;1121         if(NewState != DISABLE)
000058  b11d              CBZ      r5,|L22.98|
;;;1122         {
;;;1123           OB->RDP = 0x00;
00005a  2000              MOVS     r0,#0
00005c  4912              LDR      r1,|L22.168|
00005e  8008              STRH     r0,[r1,#0]
000060  e002              B        |L22.104|
                  |L22.98|
;;;1124         }
;;;1125         else
;;;1126         {
;;;1127           OB->RDP = RDP_Key;  
000062  20a5              MOVS     r0,#0xa5
000064  4910              LDR      r1,|L22.168|
000066  8008              STRH     r0,[r1,#0]
                  |L22.104|
;;;1128         }
;;;1129         /* Wait for last operation to be completed */
;;;1130         status = FLASH_WaitForLastOperation(EraseTimeout); 
000068  f44f2030          MOV      r0,#0xb0000
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4604              MOV      r4,r0
;;;1131       
;;;1132         if(status != FLASH_TIMEOUT)
000072  2c05              CMP      r4,#5
000074  d010              BEQ      |L22.152|
;;;1133         {
;;;1134           /* if the program operation is completed, disable the OPTPG Bit */
;;;1135           FLASH->CR &= CR_OPTPG_Reset;
000076  480a              LDR      r0,|L22.160|
000078  6900              LDR      r0,[r0,#0x10]
00007a  f64171ef          MOV      r1,#0x1fef
00007e  4008              ANDS     r0,r0,r1
000080  4907              LDR      r1,|L22.160|
000082  6108              STR      r0,[r1,#0x10]
000084  e008              B        |L22.152|
                  |L22.134|
;;;1136         }
;;;1137       }
;;;1138       else 
;;;1139       {
;;;1140         if(status != FLASH_TIMEOUT)
000086  2c05              CMP      r4,#5
000088  d006              BEQ      |L22.152|
;;;1141         {
;;;1142           /* Disable the OPTER Bit */
;;;1143           FLASH->CR &= CR_OPTER_Reset;
00008a  4805              LDR      r0,|L22.160|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f64171df          MOV      r1,#0x1fdf
000092  4008              ANDS     r0,r0,r1
000094  4902              LDR      r1,|L22.160|
000096  6108              STR      r0,[r1,#0x10]
                  |L22.152|
;;;1144         }
;;;1145       }
;;;1146     }
;;;1147     /* Return the protection operation Status */
;;;1148     return status;       
000098  4620              MOV      r0,r4
;;;1149   }
00009a  bd30              POP      {r4,r5,pc}
;;;1150   
                          ENDP

                  |L22.156|
                          DCD      0x45670123
                  |L22.160|
                          DCD      0x40022000
                  |L22.164|
                          DCD      0xcdef89ab
                  |L22.168|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;252      */
;;;253    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;254    {
;;;255      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;256      
;;;257      /* Check the parameters */
;;;258      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;259      
;;;260      /* Read the ACR register */
;;;261      tmpreg = FLASH->ACR;  
000004  4a03              LDR      r2,|L23.20|
000006  6810              LDR      r0,[r2,#0]
;;;262      
;;;263      /* Sets the Latency value */
;;;264      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;265      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;266      
;;;267      /* Write the ACR register */
;;;268      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;269    }
000010  4770              BX       lr
;;;270    
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;317      */
;;;318    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L24.12|
;;;319    {
;;;320      /* Authorize the FPEC of Bank1 Access */
;;;321      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L24.16|
000004  6048              STR      r0,[r1,#4]
;;;322      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L24.20|
000008  6048              STR      r0,[r1,#4]
;;;323    
;;;324    #ifdef STM32F10X_XL
;;;325      /* Authorize the FPEC of Bank2 Access */
;;;326      FLASH->KEYR2 = FLASH_KEY1;
;;;327      FLASH->KEYR2 = FLASH_KEY2;
;;;328    #endif /* STM32F10X_XL */
;;;329    }
00000a  4770              BX       lr
;;;330    /**
                          ENDP

                  |L24.12|
                          DCD      0x45670123
                  |L24.16|
                          DCD      0x40022000
                  |L24.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank1 PROC
;;;338      */
;;;339    void FLASH_UnlockBank1(void)
000000  4802              LDR      r0,|L25.12|
;;;340    {
;;;341      /* Authorize the FPEC of Bank1 Access */
;;;342      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L25.16|
000004  6048              STR      r0,[r1,#4]
;;;343      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L25.20|
000008  6048              STR      r0,[r1,#4]
;;;344    }
00000a  4770              BX       lr
;;;345    
                          ENDP

                  |L25.12|
                          DCD      0x45670123
                  |L25.16|
                          DCD      0x40022000
                  |L25.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;1168     */
;;;1169   FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1170   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1171     FLASH_Status status = FLASH_COMPLETE; 
000008  2404              MOVS     r4,#4
;;;1172   
;;;1173     /* Check the parameters */
;;;1174     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1175     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1176     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1177   
;;;1178     /* Authorize the small information block programming */
;;;1179     FLASH->OPTKEYR = FLASH_KEY1;
00000a  4813              LDR      r0,|L26.88|
00000c  4913              LDR      r1,|L26.92|
00000e  6088              STR      r0,[r1,#8]
;;;1180     FLASH->OPTKEYR = FLASH_KEY2;
000010  4813              LDR      r0,|L26.96|
000012  6088              STR      r0,[r1,#8]
;;;1181     
;;;1182     /* Wait for last operation to be completed */
;;;1183     status = FLASH_WaitForLastOperation(ProgramTimeout);
000014  02e0              LSLS     r0,r4,#11
000016  f7fffffe          BL       FLASH_WaitForLastOperation
00001a  4604              MOV      r4,r0
;;;1184     
;;;1185     if(status == FLASH_COMPLETE)
00001c  2c04              CMP      r4,#4
00001e  d119              BNE      |L26.84|
;;;1186     {  
;;;1187       /* Enable the Option Bytes Programming operation */
;;;1188       FLASH->CR |= CR_OPTPG_Set; 
000020  480e              LDR      r0,|L26.92|
000022  6900              LDR      r0,[r0,#0x10]
000024  f0400010          ORR      r0,r0,#0x10
000028  490c              LDR      r1,|L26.92|
00002a  6108              STR      r0,[r1,#0x10]
;;;1189              
;;;1190       OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
00002c  f04700f8          ORR      r0,r7,#0xf8
000030  4330              ORRS     r0,r0,r6
000032  4328              ORRS     r0,r0,r5
000034  490b              LDR      r1,|L26.100|
000036  8008              STRH     r0,[r1,#0]
;;;1191     
;;;1192       /* Wait for last operation to be completed */
;;;1193       status = FLASH_WaitForLastOperation(ProgramTimeout);
000038  f44f5000          MOV      r0,#0x2000
00003c  f7fffffe          BL       FLASH_WaitForLastOperation
000040  4604              MOV      r4,r0
;;;1194       if(status != FLASH_TIMEOUT)
000042  2c05              CMP      r4,#5
000044  d006              BEQ      |L26.84|
;;;1195       {
;;;1196         /* if the program operation is completed, disable the OPTPG Bit */
;;;1197         FLASH->CR &= CR_OPTPG_Reset;
000046  4805              LDR      r0,|L26.92|
000048  6900              LDR      r0,[r0,#0x10]
00004a  f64171ef          MOV      r1,#0x1fef
00004e  4008              ANDS     r0,r0,r1
000050  4902              LDR      r1,|L26.92|
000052  6108              STR      r0,[r1,#0x10]
                  |L26.84|
;;;1198       }
;;;1199     }    
;;;1200     /* Return the Option Byte program Status */
;;;1201     return status;
000054  4620              MOV      r0,r4
;;;1202   }
000056  bdf0              POP      {r4-r7,pc}
;;;1203   
                          ENDP

                  |L26.88|
                          DCD      0x45670123
                  |L26.92|
                          DCD      0x40022000
                  |L26.96|
                          DCD      0xcdef89ab
                  |L26.100|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastBank1Operation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastBank1Operation PROC
;;;1673     */
;;;1674   FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1675   { 
000002  4602              MOV      r2,r0
;;;1676     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1677      
;;;1678     /* Check for the Flash Status */
;;;1679     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1680     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1681     while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
00000c  e003              B        |L27.22|
                  |L27.14|
;;;1682     {
;;;1683       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1684       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L27.22|
000016  2b01              CMP      r3,#1                 ;1681
000018  d101              BNE      |L27.30|
00001a  2a00              CMP      r2,#0                 ;1681
00001c  d1f7              BNE      |L27.14|
                  |L27.30|
;;;1685     }
;;;1686     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L27.34|
;;;1687     {
;;;1688       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L27.34|
;;;1689     }
;;;1690     /* Return the operation status */
;;;1691     return status;
000022  4618              MOV      r0,r3
;;;1692   }
000024  bd00              POP      {pc}
;;;1693   
                          ENDP


                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1645     */
;;;1646   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1647   { 
000002  4602              MOV      r2,r0
;;;1648     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1649      
;;;1650     /* Check for the Flash Status */
;;;1651     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1652     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1653     while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e003              B        |L28.22|
                  |L28.14|
;;;1654     {
;;;1655       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1656       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L28.22|
000016  2b01              CMP      r3,#1                 ;1653
000018  d101              BNE      |L28.30|
00001a  2a00              CMP      r2,#0                 ;1653
00001c  d1f7              BNE      |L28.14|
                  |L28.30|
;;;1657     }
;;;1658     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L28.34|
;;;1659     {
;;;1660       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L28.34|
;;;1661     }
;;;1662     /* Return the operation status */
;;;1663     return status;
000022  4618              MOV      r0,r3
;;;1664   }
000024  bd00              POP      {pc}
;;;1665   
                          ENDP

