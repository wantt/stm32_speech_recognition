; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Object\system_stm32f10x.o --depend=.\Object\system_stm32f10x.d --feedback=.\Object\stm32-speech-recognition.fed --cpu=Cortex-M3 --apcs=interwork -O0 -Otime -I.\Src\APP -I.\Src\BSP -I.\Src\GUI -I.\Src\CM3_SYS -I.\Src\FATFS -I.\Src\StdPeriph_Driver -I.\Src\StdPeriph_Driver\inc -I.\Src\Speech_Recog -IE:\SoftWare\KEIL\Keil4\path\ARM\INC -IE:\SoftWare\KEIL\Keil4\path\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\Object\system_stm32f10x.crf Src\StdPeriph_Driver\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=1

                  SetSysClock PROC
;;;343      */
;;;344    static void SetSysClock(void)
000000  b510              PUSH     {r4,lr}
;;;345    {
;;;346    #ifdef SYSCLK_FREQ_HSE
;;;347      SetSysClockToHSE();
;;;348    #elif defined SYSCLK_FREQ_24MHz
;;;349      SetSysClockTo24();
;;;350    #elif defined SYSCLK_FREQ_36MHz
;;;351      SetSysClockTo36();
;;;352    #elif defined SYSCLK_FREQ_48MHz
;;;353      SetSysClockTo48();
;;;354    #elif defined SYSCLK_FREQ_56MHz
;;;355      SetSysClockTo56();  
;;;356    #elif defined SYSCLK_FREQ_72MHz
;;;357      SetSysClockTo72();
000002  f7fffffe          BL       SetSysClockTo72
;;;358    #endif
;;;359     
;;;360     /* If none of the define above is enabled, the HSI is used as System clock
;;;361        source (default after reset) */ 
;;;362    }
000006  bd10              POP      {r4,pc}
;;;363    
                          ENDP


                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;911      */
;;;912    static void SetSysClockTo72(void)
000000  2100              MOVS     r1,#0
;;;913    {
;;;914      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
;;;915      
;;;916      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;917      /* Enable HSE */    
;;;918      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000004  4a2e              LDR      r2,|L2.192|
000006  6812              LDR      r2,[r2,#0]
000008  f4423280          ORR      r2,r2,#0x10000
00000c  4b2c              LDR      r3,|L2.192|
00000e  601a              STR      r2,[r3,#0]
;;;919     
;;;920      /* Wait till HSE is ready and if Time out is reached exit */
;;;921      do
000010  bf00              NOP      
                  |L2.18|
;;;922      {
;;;923        HSEStatus = RCC->CR & RCC_CR_HSERDY;
000012  4a2b              LDR      r2,|L2.192|
000014  6812              LDR      r2,[r2,#0]
000016  f4023000          AND      r0,r2,#0x20000
;;;924        StartUpCounter++;  
00001a  1c49              ADDS     r1,r1,#1
;;;925      } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
00001c  b910              CBNZ     r0,|L2.36|
00001e  f5b16fa0          CMP      r1,#0x500
000022  d1f6              BNE      |L2.18|
                  |L2.36|
;;;926    
;;;927      if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000024  4a26              LDR      r2,|L2.192|
000026  6812              LDR      r2,[r2,#0]
000028  f4123f00          TST      r2,#0x20000
00002c  d001              BEQ      |L2.50|
;;;928      {
;;;929        HSEStatus = (uint32_t)0x01;
00002e  2001              MOVS     r0,#1
000030  e000              B        |L2.52|
                  |L2.50|
;;;930      }
;;;931      else
;;;932      {
;;;933        HSEStatus = (uint32_t)0x00;
000032  2000              MOVS     r0,#0
                  |L2.52|
;;;934      }  
;;;935    
;;;936      if (HSEStatus == (uint32_t)0x01)
000034  2801              CMP      r0,#1
000036  d142              BNE      |L2.190|
;;;937      {
;;;938        /* Enable Prefetch Buffer */
;;;939        FLASH->ACR |= FLASH_ACR_PRFTBE;
000038  4a22              LDR      r2,|L2.196|
00003a  6812              LDR      r2,[r2,#0]
00003c  f0420210          ORR      r2,r2,#0x10
000040  4b20              LDR      r3,|L2.196|
000042  601a              STR      r2,[r3,#0]
;;;940    
;;;941        /* Flash 2 wait state */
;;;942        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000044  461a              MOV      r2,r3
000046  6812              LDR      r2,[r2,#0]
000048  f0220203          BIC      r2,r2,#3
00004c  601a              STR      r2,[r3,#0]
;;;943        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
00004e  461a              MOV      r2,r3
000050  6812              LDR      r2,[r2,#0]
000052  f0420202          ORR      r2,r2,#2
000056  601a              STR      r2,[r3,#0]
;;;944    
;;;945     
;;;946        /* HCLK = SYSCLK */
;;;947        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
000058  4a19              LDR      r2,|L2.192|
00005a  6852              LDR      r2,[r2,#4]
00005c  4b18              LDR      r3,|L2.192|
00005e  605a              STR      r2,[r3,#4]
;;;948          
;;;949        /* PCLK2 = HCLK */
;;;950        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000060  461a              MOV      r2,r3
000062  6852              LDR      r2,[r2,#4]
000064  605a              STR      r2,[r3,#4]
;;;951        
;;;952        /* PCLK1 = HCLK/2 */
;;;953        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
000066  461a              MOV      r2,r3
000068  6852              LDR      r2,[r2,#4]
00006a  f4426280          ORR      r2,r2,#0x400
00006e  605a              STR      r2,[r3,#4]
;;;954    
;;;955    #ifdef STM32F10X_CL
;;;956        /* Configure PLLs ------------------------------------------------------*/
;;;957        /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;958        /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;959            
;;;960        RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;961                                  RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;962        RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;963                                 RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;964      
;;;965        /* Enable PLL2 */
;;;966        RCC->CR |= RCC_CR_PLL2ON;
;;;967        /* Wait till PLL2 is ready */
;;;968        while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;969        {
;;;970        }
;;;971        
;;;972       
;;;973        /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;974        RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;975        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;976                                RCC_CFGR_PLLMULL9); 
;;;977    #else    
;;;978        /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;979        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000070  461a              MOV      r2,r3
000072  6852              LDR      r2,[r2,#4]
000074  f422127c          BIC      r2,r2,#0x3f0000
000078  605a              STR      r2,[r3,#4]
;;;980                                            RCC_CFGR_PLLMULL));
;;;981        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
00007a  461a              MOV      r2,r3
00007c  6852              LDR      r2,[r2,#4]
00007e  f44212e8          ORR      r2,r2,#0x1d0000
000082  605a              STR      r2,[r3,#4]
;;;982    #endif /* STM32F10X_CL */
;;;983    
;;;984        /* Enable PLL */
;;;985        RCC->CR |= RCC_CR_PLLON;
000084  461a              MOV      r2,r3
000086  6812              LDR      r2,[r2,#0]
000088  f0427280          ORR      r2,r2,#0x1000000
00008c  601a              STR      r2,[r3,#0]
;;;986    
;;;987        /* Wait till PLL is ready */
;;;988        while((RCC->CR & RCC_CR_PLLRDY) == 0)
00008e  bf00              NOP      
                  |L2.144|
000090  4a0b              LDR      r2,|L2.192|
000092  6812              LDR      r2,[r2,#0]
000094  f0127f00          TST      r2,#0x2000000
000098  d0fa              BEQ      |L2.144|
;;;989        {
;;;990        }
;;;991        
;;;992        /* Select PLL as system clock source */
;;;993        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
00009a  4a09              LDR      r2,|L2.192|
00009c  6852              LDR      r2,[r2,#4]
00009e  f0220203          BIC      r2,r2,#3
0000a2  4b07              LDR      r3,|L2.192|
0000a4  605a              STR      r2,[r3,#4]
;;;994        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
0000a6  461a              MOV      r2,r3
0000a8  6852              LDR      r2,[r2,#4]
0000aa  f0420202          ORR      r2,r2,#2
0000ae  605a              STR      r2,[r3,#4]
;;;995    
;;;996        /* Wait till PLL is used as system clock source */
;;;997        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000b0  bf00              NOP      
                  |L2.178|
0000b2  4a03              LDR      r2,|L2.192|
0000b4  6852              LDR      r2,[r2,#4]
0000b6  f002020c          AND      r2,r2,#0xc
0000ba  2a08              CMP      r2,#8
0000bc  d1f9              BNE      |L2.178|
                  |L2.190|
;;;998        {
;;;999        }
;;;1000     }
;;;1001     else
;;;1002     { /* If HSE fails to start-up, the application will have wrong clock 
;;;1003            configuration. User can add here some code to deal with this error */
;;;1004     }
;;;1005   }
0000be  4770              BX       lr
;;;1006   #endif
                          ENDP

                  |L2.192|
                          DCD      0x40021000
                  |L2.196|
                          DCD      0x40022000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;230      */
;;;231    void SystemCoreClockUpdate (void)
000000  b510              PUSH     {r4,lr}
;;;232    {
;;;233      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
000002  2100              MOVS     r1,#0
000004  2000              MOVS     r0,#0
000006  2200              MOVS     r2,#0
;;;234    
;;;235    #ifdef  STM32F10X_CL
;;;236      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;237    #endif /* STM32F10X_CL */
;;;238    
;;;239    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
;;;240      uint32_t prediv1factor = 0;
;;;241    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL */
;;;242        
;;;243      /* Get SYSCLK source -------------------------------------------------------*/
;;;244      tmp = RCC->CFGR & RCC_CFGR_SWS;
000008  4b21              LDR      r3,|L3.144|
00000a  685b              LDR      r3,[r3,#4]
00000c  f003010c          AND      r1,r3,#0xc
;;;245      
;;;246      switch (tmp)
000010  b121              CBZ      r1,|L3.28|
000012  2904              CMP      r1,#4
000014  d006              BEQ      |L3.36|
000016  2908              CMP      r1,#8
000018  d128              BNE      |L3.108|
00001a  e007              B        |L3.44|
                  |L3.28|
;;;247      {
;;;248        case 0x00:  /* HSI used as system clock */
;;;249          SystemCoreClock = HSI_Value;
00001c  4b1d              LDR      r3,|L3.148|
00001e  4c1e              LDR      r4,|L3.152|
000020  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;250          break;
000022  e027              B        |L3.116|
                  |L3.36|
;;;251        case 0x04:  /* HSE used as system clock */
;;;252          SystemCoreClock = HSE_Value;
000024  4b1b              LDR      r3,|L3.148|
000026  4c1c              LDR      r4,|L3.152|
000028  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;253          break;
00002a  e023              B        |L3.116|
                  |L3.44|
;;;254        case 0x08:  /* PLL used as system clock */
;;;255    
;;;256          /* Get PLL clock source and multiplication factor ----------------------*/
;;;257          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00002c  4b18              LDR      r3,|L3.144|
00002e  685b              LDR      r3,[r3,#4]
000030  f4031070          AND      r0,r3,#0x3c0000
;;;258          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000034  4b16              LDR      r3,|L3.144|
000036  685b              LDR      r3,[r3,#4]
000038  f4033280          AND      r2,r3,#0x10000
;;;259          
;;;260    #ifndef STM32F10X_CL      
;;;261          pllmull = ( pllmull >> 18) + 2;
00003c  2302              MOVS     r3,#2
00003e  eb034090          ADD      r0,r3,r0,LSR #18
;;;262          
;;;263          if (pllsource == 0x00)
000042  b922              CBNZ     r2,|L3.78|
;;;264          {
;;;265            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;266            SystemCoreClock = (HSI_Value >> 1) * pllmull;
000044  4b15              LDR      r3,|L3.156|
000046  4343              MULS     r3,r0,r3
000048  4c13              LDR      r4,|L3.152|
00004a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
00004c  e00d              B        |L3.106|
                  |L3.78|
;;;267          }
;;;268          else
;;;269          {
;;;270     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
;;;271           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;272           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;273           SystemCoreClock = (HSE_Value / prediv1factor) * pllmull; 
;;;274     #else
;;;275            /* HSE selected as PLL clock entry */
;;;276            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
00004e  4b10              LDR      r3,|L3.144|
000050  685b              LDR      r3,[r3,#4]
000052  f4133f00          TST      r3,#0x20000
000056  d004              BEQ      |L3.98|
;;;277            {/* HSE oscillator clock divided by 2 */
;;;278              SystemCoreClock = (HSE_Value >> 1) * pllmull;
000058  4b10              LDR      r3,|L3.156|
00005a  4343              MULS     r3,r0,r3
00005c  4c0e              LDR      r4,|L3.152|
00005e  6023              STR      r3,[r4,#0]  ; SystemCoreClock
000060  e003              B        |L3.106|
                  |L3.98|
;;;279            }
;;;280            else
;;;281            {
;;;282              SystemCoreClock = HSE_Value * pllmull;
000062  4b0c              LDR      r3,|L3.148|
000064  4343              MULS     r3,r0,r3
000066  4c0c              LDR      r4,|L3.152|
000068  6023              STR      r3,[r4,#0]  ; SystemCoreClock
                  |L3.106|
;;;283            }
;;;284     #endif
;;;285          }
;;;286    #else
;;;287          pllmull = pllmull >> 18;
;;;288          
;;;289          if (pllmull != 0x0D)
;;;290          {
;;;291             pllmull += 2;
;;;292          }
;;;293          else
;;;294          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;295            pllmull = 13 / 2; 
;;;296          }
;;;297                
;;;298          if (pllsource == 0x00)
;;;299          {
;;;300            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;301            SystemCoreClock = (HSI_Value >> 1) * pllmull;
;;;302          }
;;;303          else
;;;304          {/* PREDIV1 selected as PLL clock entry */
;;;305            
;;;306            /* Get PREDIV1 clock source and division factor */
;;;307            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;308            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;309            
;;;310            if (prediv1source == 0)
;;;311            { 
;;;312              /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;313              SystemCoreClock = (HSE_Value / prediv1factor) * pllmull;          
;;;314            }
;;;315            else
;;;316            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;317              
;;;318              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;319              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;320              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;321              SystemCoreClock = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;322            }
;;;323          }
;;;324    #endif /* STM32F10X_CL */ 
;;;325          break;
00006a  e003              B        |L3.116|
                  |L3.108|
;;;326    
;;;327        default:
;;;328          SystemCoreClock = HSI_Value;
00006c  4b09              LDR      r3,|L3.148|
00006e  4c0a              LDR      r4,|L3.152|
000070  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;329          break;
000072  bf00              NOP      
                  |L3.116|
000074  bf00              NOP                            ;250
;;;330      }
;;;331      
;;;332      /* Compute HCLK clock frequency ----------------*/
;;;333      /* Get HCLK prescaler */
;;;334      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
000076  4b06              LDR      r3,|L3.144|
000078  685b              LDR      r3,[r3,#4]
00007a  f3c31303          UBFX     r3,r3,#4,#4
00007e  4c08              LDR      r4,|L3.160|
000080  5ce1              LDRB     r1,[r4,r3]
;;;335      /* HCLK clock frequency */
;;;336      SystemCoreClock >>= tmp;  
000082  4b05              LDR      r3,|L3.152|
000084  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
000086  40cb              LSRS     r3,r3,r1
000088  4c03              LDR      r4,|L3.152|
00008a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;337    }
00008c  bd10              POP      {r4,pc}
;;;338    
                          ENDP

00008e  0000              DCW      0x0000
                  |L3.144|
                          DCD      0x40021000
                  |L3.148|
                          DCD      0x007a1200
                  |L3.152|
                          DCD      SystemCoreClock
                  |L3.156|
                          DCD      0x003d0900
                  |L3.160|
                          DCD      AHBPrescTable

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;171      */
;;;172    void SystemInit (void)
000000  b510              PUSH     {r4,lr}
;;;173    {
;;;174      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;175      /* Set HSION bit */
;;;176      RCC->CR |= (uint32_t)0x00000001;
000002  4811              LDR      r0,|L4.72|
000004  6800              LDR      r0,[r0,#0]
000006  f0400001          ORR      r0,r0,#1
00000a  490f              LDR      r1,|L4.72|
00000c  6008              STR      r0,[r1,#0]
;;;177    
;;;178      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;179    #ifndef STM32F10X_CL
;;;180      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000e  4608              MOV      r0,r1
000010  6840              LDR      r0,[r0,#4]
000012  490e              LDR      r1,|L4.76|
000014  4008              ANDS     r0,r0,r1
000016  490c              LDR      r1,|L4.72|
000018  6048              STR      r0,[r1,#4]
;;;181    #else
;;;182      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;183    #endif /* STM32F10X_CL */   
;;;184      
;;;185      /* Reset HSEON, CSSON and PLLON bits */
;;;186      RCC->CR &= (uint32_t)0xFEF6FFFF;
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]
00001e  490c              LDR      r1,|L4.80|
000020  4008              ANDS     r0,r0,r1
000022  4909              LDR      r1,|L4.72|
000024  6008              STR      r0,[r1,#0]
;;;187    
;;;188      /* Reset HSEBYP bit */
;;;189      RCC->CR &= (uint32_t)0xFFFBFFFF;
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]
00002a  f4202080          BIC      r0,r0,#0x40000
00002e  6008              STR      r0,[r1,#0]
;;;190    
;;;191      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;192      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000030  4608              MOV      r0,r1
000032  6840              LDR      r0,[r0,#4]
000034  f42000fe          BIC      r0,r0,#0x7f0000
000038  6048              STR      r0,[r1,#4]
;;;193    
;;;194    #ifdef STM32F10X_CL
;;;195      /* Reset PLL2ON and PLL3ON bits */
;;;196      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;197    
;;;198      /* Disable all interrupts and clear pending bits  */
;;;199      RCC->CIR = 0x00FF0000;
;;;200    
;;;201      /* Reset CFGR2 register */
;;;202      RCC->CFGR2 = 0x00000000;
;;;203    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) 
;;;204      /* Disable all interrupts and clear pending bits  */
;;;205      RCC->CIR = 0x009F0000;
;;;206    
;;;207      /* Reset CFGR2 register */
;;;208      RCC->CFGR2 = 0x00000000;      
;;;209    #else
;;;210      /* Disable all interrupts and clear pending bits  */
;;;211      RCC->CIR = 0x009F0000;
00003a  f44f001f          MOV      r0,#0x9f0000
00003e  6088              STR      r0,[r1,#8]
;;;212    #endif /* STM32F10X_CL */
;;;213        
;;;214    #if defined (STM32F10X_HD) || (defined STM32F10X_XL)
;;;215      #ifdef DATA_IN_ExtSRAM
;;;216        SystemInit_ExtMemCtl(); 
;;;217      #endif /* DATA_IN_ExtSRAM */
;;;218    #endif 
;;;219    
;;;220      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;221      /* Configure the Flash Latency cycles and enable prefetch buffer*/ 
;;;222      SetSysClock();													
000040  f7fffffe          BL       SetSysClock
;;;223    }
000044  bd10              POP      {r4,pc}
;;;224    
                          ENDP

000046  0000              DCW      0x0000
                  |L4.72|
                          DCD      0x40021000
                  |L4.76|
                          DCD      0xf8ff0000
                  |L4.80|
                          DCD      0xfef6ffff

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
